[
  {
    "path": "posts/visualiser-donnees-ggplot2/",
    "title": "Visualisation de données",
    "description": "Créer des graphiques avec ggplot2.",
    "author": [
      {
        "name": "Jonathan Kitt",
        "url": {}
      }
    ],
    "date": "2022-06-30",
    "categories": [
      "R",
      "RStudio",
      "Graphiques",
      "ggpplot2",
      "Tidyverse"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nConstruire un graphique ggplot2\r\nCréer des graphiques basiques\r\nGraphiques multiples\r\nExporter un graphique\r\nAméliorer ses graphiques\r\n\r\nIntroduction\r\n\r\n\r\n\r\nDessin de Allison Horst\r\n\r\nNous avons vu comment importer nos données dans RStudio, et comment les manipuler et les mettre en forme.\r\n\r\nDans ce tutoriel nous allons voir comment communiquer les résultats de nos analyses - à l’aide de la visualisation de données :\r\n\r\n1. Construire un graphique ggplot2\r\n3. Créer des graphiques basiques :\r\nnuage de points (scatter plot)\r\nhistogramme\r\nboîtes à moustaches (box plot)\r\ndiagramme en bâtons (bar plot)\r\ngraphiques multiples (facet)\r\n3. Exporter un graphique\r\n4. Améliorer ses graphiques\r\n5. Assembler ses graphiques à l’aide de patchwork\r\n6. Défi\r\n\r\nConstruire un graphique ggplot2\r\nLe package ggplot2 (qui fait partie de la suite Tidyverse) repose sur le principe de grammaire des graphiques : notre visualisation se construit étape par étape, en procédant par couches, comme le montre la figure ci-dessous.\r\n\r\n\r\n\r\nFigure tirée de ggplot2 et la grammaire des graphiques\r\n\r\nToutes ces couches ne sont pas nécessaires à la construction d’un graphique.\r\nLa figure ci-dessous montre de manière simplifiée comment créer un ggplot basique :\r\n1) ggplot() : initialisation de l’outil graphique\r\n2) aes() : paramètres esthétiques (répartition des variables sur les axes, couleurs, …)\r\n3) geom() : type de représentation (points, lignes, …)\r\n4) theme() : apparence du graphique (arrière-plan, taille et alignement du texte, …)\r\n\r\n\r\n\r\nVous remarquerez dans le code la présence du signe “+” à la fin de chaque ligne : c’est ce qui permet d’ajouter une couche à votre graphique.\r\nCréer des graphiques basiques\r\nCommençons par ouvrir un nouveau script R et importer le jeu de données :\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\npingouins <- readr::read_csv(\"https://raw.githubusercontent.com/codons-blog/C-04-VisualisationDonnees/main/pingouins.csv\")\r\n\r\n\r\n\r\n\r\n\r\n# Ateliers codons!\r\n# 04 - Visualisation de donnees avec ggplot2\r\n# 2022-06-30\r\n\r\n# Definir le repertoire de travail ----\r\n\r\nsetwd(\"codons/C-04-VisualisationDonnees\")\r\n\r\n# Charger le Tidyverse ----\r\n\r\nlibrary(tidyverse)\r\n\r\n# Importer le jeu de donnees ----\r\n\r\npingouins <- readr::read_csv(\"https://raw.githubusercontent.com/codons-blog/C-04-VisualisationDonnees/main/pingouins.csv\")\r\n\r\n\r\n\r\n\r\nIl est toujours utile de vérifier les données importées avant d’aller plus loin :\r\n\r\n\r\nglimpse(pingouins)\r\n\r\n\r\nRows: 342\r\nColumns: 6\r\n$ espece       <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie~\r\n$ ile          <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgers~\r\n$ bec_lngr_mm  <dbl> 39.1, 39.5, 40.3, 36.7, 39.3, 38.9, 39.2, 34.1,~\r\n$ bec_htr_mm   <dbl> 18.7, 17.4, 18.0, 19.3, 20.6, 17.8, 19.6, 18.1,~\r\n$ aile_lngr_mm <dbl> 181, 186, 195, 193, 190, 181, 195, 193, 190, 18~\r\n$ masse_g      <dbl> 3750, 3800, 3250, 3450, 3650, 3625, 4675, 3475,~\r\n\r\n\r\nIl s’agit du jeu de données Palmer penguins, disponible dans le package R palmerpenguins.\r\nDifférents paramètres ont été mesurés sur trois espèces de pingouins, sur trois îles de l’archipel Palmer en Antarctique.\r\n\r\n\r\n\r\nDessin de Allison Horst\r\nNuage de points (scatter plot)\r\nIntéressons-nous au bec des pingouins en répondant à la question suivante : quelle est la distribution du rapport entre la hauteur du bec et sa longueur ?.\r\nAfin de bien comprendre comment construire un graphique avec ggplot2, procédons étape par étape.\r\n\r\n\r\n\r\n# Initialiser l'outil graphique\r\nggplot(data = pingouins)\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Paramètres esthétiques : répartition des variables sur les axes\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm))\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Type de visualisation : points\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point()\r\n\r\n\r\n\r\n\r\n\r\nVoilà la distribution que nous cherchons à observer. C’est un bon début, mais cela manque de couleurs …\r\nIl existe deux façons d’ajouter des couleurs à un ggplot :\r\ndéfinir une couleur pour l’ensemble des points : on placera alors le paramètre couleur en dehors de la parenthèse aes().\r\n\r\n\r\n# Une couleur pour l'ensemble des points\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point(colour = \"red\")\r\n\r\n\r\n\r\n\r\ncolorer les points en fonction d’une autre variable : on placera dans ce cas le paramètre couleur à l’intérieur de la parenthèse aes().\r\n\r\n\r\n# Colorer les points en fonction de l'espece\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point(aes(colour = espece))\r\n\r\n\r\n\r\n\r\nVous pouvez voir qu’une légende permettant de différencier les trois espèces a été ajoutée à droite du graphique.\r\nNous aimerions utiliser les mêmes couleurs que celles de la documentation du jeu de données. Nous utilisons pour cela le paramètre scale_colour_manual() :\r\n\r\n\r\n# Modifier les couleurs\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point(aes(colour = espece)) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\"))\r\n\r\n\r\n\r\n\r\nLa taille des points nous semble trop petite : nous allons l’augmenter à l’aide de size :\r\n\r\nPrend une valeur numérique, par défaut 1\r\n\r\n\r\n# Augmenter la taille des points\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point(aes(colour = espece),\r\n             size = 3) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\"))\r\n\r\n\r\n\r\n\r\nAfin de rendre le graphique plus lisible, nous pouvons ajouter de la transparence aux points à l’aide du paramètre alpha :\r\n\r\nEntre 0 et 1, par opacité croissante\r\n\r\n\r\n# Ajouter de la transparence\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point(aes(colour = espece),\r\n             size = 3,\r\n             alpha = 0.5) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\"))\r\n\r\n\r\n\r\n\r\nNous allons maintenant ajouter un titre et un sous-titre à notre graphique, et modifier les titres des axes pour les rendre plus explicites :\r\n\r\n\r\n# Ajouter ou modifier les titres du graphique et des axes\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point(aes(colour = espece),\r\n             size = 3,\r\n             alpha = 0.5) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Rapport entre la hauteur et la longueur du bec\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Longueur du bec (mm)\",\r\n       y = \"Hauteur du bec (mm)\")\r\n\r\n\r\n\r\n\r\nLe fond gris du graphique est proposé par défaut par ggplot2 : il s’agit d’un thème définissant l’apparence générale du graphique (couleurs de l’arrière-plan, de la grille, présence ou non d’un cadre, …). Nous allons utiliser l’un des autres thèmes prédéfinis dans ggplot2, le thème “minimal” à l’aide du paramètre theme_minimal().\r\n Il en existe d’autres : theme_light(), theme_bw(), theme_void(), … N’hésitez pas à les essayer pour trouver celui qui vous convient le mieux !\r\n\r\n\r\n# Changer le thème\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point(aes(colour = espece),\r\n             size = 3,\r\n             alpha = 0.5) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Rapport entre la hauteur et la longueur du bec\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Longueur du bec (mm)\",\r\n       y = \"Hauteur du bec (mm)\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nUne note sur les formes et les couleurs\r\nNous pourrions également modifier la forme de nos points, à l’aide du paramètre shape. Il existe 25 types de points, comme montré ci-dessous.\r\n\r\n\r\n\r\nLa façon de colorer les points dépend de la forme choisie :\r\ncouleur appliquée au contour pour les formes 0 à 14 à l’aide de colour = ...\r\ncouleur appliquée à l’intérieur pour les formes 15 à 20 à l’aide de fill = ...\r\ncouleur appliquée au contour et à l’intérieur pour les formes 21 à 24 à l’aide de ces deux paramètres, avec la même couleur ou des couleurs différentes. Pour ces cinq formes, la largeur du contour peut être modifiée à l’aide de stroke = ... (prend une valeur numérique).\r\nPour donner un exemple, nous pouvons ajouter à nos points un contour noir :\r\n\r\n\r\n# Changer la forme des points\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point(aes(fill = espece),\r\n             shape = 23,\r\n             stroke = 2,\r\n             colour = \"black\",\r\n             size = 3,\r\n             alpha = 0.5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Rapport entre la hauteur et la longueur du bec\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Longueur du bec (mm)\",\r\n       y = \"Hauteur du bec (mm)\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nAttention à la logique du code !! Nous avons choisi de colorer l’intérieur de nos points en fonction de l’espèce : geom_point(aes(fill = espece)). Il faut donc modifier la ligne qui nous permet de changer les couleurs : scale_fill_manual() remplace scale_colour_manual() utilisé précédemment.\r\n\r\nLe package ggplot2 propose de nombreuses palettes de couleurs :\r\nPalettes prédéfinies dans ggplot2\r\n\r\n\r\n\r\nCes différentes palettes peuvent être utilisées à l’aide de scale_colour_brewer() ou scale_fill_brewer(). Essayons la palette Set3 :\r\n\r\n\r\n# Utiliser une palette de couleurs\r\nggplot(data = pingouins,\r\n       mapping = aes(x = bec_lngr_mm,\r\n                     y = bec_htr_mm)) +\r\n  geom_point(aes(colour = espece),\r\n             size = 3,\r\n             alpha = 0.5) +\r\n  scale_colour_brewer(palette = \"Set3\") +\r\n  labs(title = \"Rapport entre la hauteur et la longueur du bec\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Longueur du bec (mm)\",\r\n       y = \"Hauteur du bec (mm)\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nIl existe beaucoup d’autres palettes, accessibles via des packages, dont la liste est accessible ici.\r\nHistogramme\r\nEssayons maintenant de répondre à la question suivante : quelle est la distribution de la longueur des ailes ?.  Nous allons pour cela générer un histogramme à l’aide de geom_histogram() :\r\n\r\n\r\n# Histogramme\r\nggplot(data = pingouins,\r\n       mapping = aes(x = aile_lngr_mm)) +\r\n  geom_histogram(aes(fill = espece),\r\n                 alpha = 0.5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la longueur des ailes\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Longueur des ailes (mm)\",\r\n       y = \"Fréquence\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nIl existe trois manières d’arranger la position des histogrammes des différents groupes :\r\n1) position = \"stack (par défaut) : voir ci-dessus.\r\n2) position = \"identity :\r\n\r\n\r\n# Histogramme - position = \"identity\"\r\nggplot(data = pingouins,\r\n       mapping = aes(x = aile_lngr_mm)) +\r\n  geom_histogram(aes(fill = espece),\r\n                 alpha = 0.5,\r\n                 position = \"identity\") +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la longueur des ailes\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Longueur des ailes (mm)\",\r\n       y = \"Fréquence\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\n3) position = \"dodge\r\n\r\n\r\n# Histogramme - position = \"dodge\"\r\nggplot(data = pingouins,\r\n       mapping = aes(x = aile_lngr_mm)) +\r\n  geom_histogram(aes(fill = espece),\r\n                 alpha = 0.5,\r\n                 position = \"dodge\") +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la longueur des ailes\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Longueur des ailes (mm)\",\r\n       y = \"Fréquence\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nLorsque vous exécutez ce code, vous pouvez lire le message suivant dans la console : stat_bin() using bins = 30. Pick better value with binwidth.\r\n\r\nCela vous signale que le nombre de classes (bins) choisi pour l’histogramme n’est peut-être pas idéal.\r\n\r\nVous pouvez modifier ces classes de deux façons :\r\n1) en modifiant la largeur de chaque classe sur l’axe x : binwidth = ...\r\n2) en modifiant le nombre de classes à afficher : bins = ...\r\n\r\nModifions ces paramètres pour voir le résultat :\r\n\r\n\r\n# Histogramme - position = \"identity\" - binwidth = 0.5\r\nggplot(data = pingouins,\r\n       mapping = aes(x = aile_lngr_mm)) +\r\n  geom_histogram(aes(fill = espece),\r\n                 alpha = 0.5,\r\n                 position = \"identity\",\r\n                 binwidth = 0.5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la longueur des ailes\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Longueur des ailes (mm)\",\r\n       y = \"Fréquence\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Histogramme - position = \"identity\" - bins = 15\r\nggplot(data = pingouins,\r\n       mapping = aes(x = aile_lngr_mm)) +\r\n  geom_histogram(aes(fill = espece),\r\n                 alpha = 0.5,\r\n                 position = \"identity\",\r\n                 bins = 15) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la longueur des ailes\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Longueur des ailes (mm)\",\r\n       y = \"Fréquence\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nBoîtes à moustaches (box plot)\r\nIntéressons-nous maintenant à la masse de nos pingouins : les masses des trois espèces sont-elles similaires ?\r\n\r\nNous allons créer un graphique en boîte à moustaches à l’aide de geom_boxplot() :\r\n\r\n\r\n# Boxplots\r\nggplot(data = pingouins,\r\n       mapping = aes(x = espece,\r\n                     y = masse_g)) +\r\n  geom_boxplot(aes(colour = espece)) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la masse corporelle\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Espèce\",\r\n       y = \"Masse (g)\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nNous pouvons apporter quelques modifications à ce graphique :\r\ncomme il y a une boîte à moustaches par espèce, nous pouvons supprimer la légende à l’aide de show_legend = FALSE\r\npour la même raison, nous pouvons supprimer le titre de l’axe x : labs(x = \"\")\r\nnous pouvons supprimer les données aberrantes (outliers) : outlier.shape = NA\r\nréduire la largeur des boxplots avec width\r\najouter de la couleur à l’intérieur des boîtes à moustaches avec aes(fill = espece) : bien penser à ajouter scale_fill_manual() !\r\naugmenter l’épaisseur des lignes avec lwd (line width)\r\n\r\n\r\n# Boxplots avec quelques modifications\r\nggplot(data = pingouins,\r\n       mapping = aes(x = espece,\r\n                     y = masse_g)) +\r\n  geom_boxplot(aes(colour = espece,\r\n                   fill = espece),\r\n               show.legend = FALSE,\r\n               outlier.shape = NA,\r\n               width = 0.25,\r\n               alpha = 0.5,\r\n               lwd = 0.75) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la masse corporelle\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"Masse (g)\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\n\r\nSi nous préférons des boxplots horizontaux, nous pouvons procéder de deux façons :\r\n1) inverser les variables x et y, en pensant bien à modifier également les titres des axes avec labs() :\r\n\r\n\r\n# Boxplots horizontaux : inverser les variables x et y\r\nggplot(data = pingouins,\r\n       mapping = aes(x = masse_g,\r\n                     y = espece)) +\r\n  geom_boxplot(aes(colour = espece,\r\n                   fill = espece),\r\n               show.legend = FALSE,\r\n               outlier.shape = NA,\r\n               width = 0.25,\r\n               alpha = 0.5,\r\n               lwd = 0.75) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la masse corporelle\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"Masse (g)\",\r\n       y = \"\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\n2) utiliser coord_flip() pour inverser les coordonnées :\r\n\r\n\r\n# Boxplots horizontaux : inverser les coordonnées avec coord_flip()\r\nggplot(data = pingouins,\r\n       mapping = aes(x = espece,\r\n                     y = masse_g)) +\r\n  geom_boxplot(aes(colour = espece,\r\n                   fill = espece),\r\n               show.legend = FALSE,\r\n               outlier.shape = NA,\r\n               width = 0.25,\r\n               alpha = 0.5,\r\n               lwd = 0.75) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la masse corporelle\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"Masse (g)\") +\r\n  coord_flip() +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nNous pouvons ajouter à ces box plots des scatter plots pour visualiser les données sous-jacentes :\r\n\r\n\r\n# Boxplots + scatter plots\r\nggplot(data = pingouins,\r\n       mapping = aes(x = espece,\r\n                     y = masse_g)) +\r\n  geom_boxplot(aes(colour = espece,\r\n                   fill = espece),\r\n               show.legend = FALSE,\r\n               outlier.shape = NA,\r\n               width = 0.25,\r\n               alpha = 0.5,\r\n               lwd = 0.75) +\r\n  geom_point(aes(colour = espece),\r\n             show.legend = FALSE,\r\n             alpha = 0.25) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la masse corporelle\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"Masse (g)\") +\r\n  coord_flip() +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nNous aimerions espacer un peu les points pour rendre le graphique plus lisible. Nous allons pour cela utiliser un autre type de visualisation de nuages de points : geom_jitter(). Les paramètres height et width permettent d’ajuster l’étalement du nuage respectivement en hauteur et en largeur. L’utilisation de l’un ou l’autre de ces paramètres dépendra de l’orientation de nos nuages de points (répartition des variables sur les axes x et y et utilisation de coord_flip()).\r\n\r\n\r\n# Boxplots + geom_jitter()\r\nggplot(data = pingouins,\r\n       mapping = aes(x = espece,\r\n                     y = masse_g)) +\r\n  geom_boxplot(aes(colour = espece,\r\n                   fill = espece),\r\n               show.legend = FALSE,\r\n               outlier.shape = NA,\r\n               width = 0.25,\r\n               alpha = 0.5,\r\n               lwd = 0.75) +\r\n  geom_jitter(aes(colour = espece),\r\n             show.legend = FALSE,\r\n             alpha = 0.25,\r\n             width = 0.25) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Distribution de la masse corporelle\",\r\n       subtitle = \"pour trois espèces de pingouins de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"Masse (g)\") +\r\n  coord_flip() +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nDiagramme en bâtons (bar plot)\r\nQuelle espèce compte le plus de pingouins ?\r\nNous allons utiliser geom_bar() pour visualiser le nombre de pingouins par espèce :\r\n\r\n\r\n# Barplot\r\nggplot(data = pingouins,\r\n       mapping = aes(x = espece,\r\n                     fill = espece)) +\r\n  geom_bar(show.legend = FALSE) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nLes espèces étant déjà notées sur l’axe x, nous utilisons show.legend = FALSE pour alléger le graphique.\r\nNous souhaiterions ajouter des étiquettes de texte au-dessus des barres pour indiquer le nombre de pingouins par espèce. Nous allons pour cela ajouter une couche à l’aide de geom_text() :\r\naes(label = ..count..) : indique que les étiquettes contiendront le nombre d’observations par groupe défini précédemment (les espèces).\r\nstat = \"count\" : nécessaire pour que le code fonctionne.\r\nvjust = -1 : alignement vertical des étiquettes, vous pouvez essayer différentes valeurs pour voir le résultat.\r\n\r\n\r\n# Barplot + geom_text()\r\nggplot(data = pingouins,\r\n       mapping = aes(x = espece,\r\n                     fill = espece)) +\r\n  geom_bar(show.legend = FALSE) +\r\n  geom_text(aes(label = ..count..),\r\n            stat = \"count\",\r\n            vjust = -1) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nVous pouvez voir que l’étiquette pour l’espèce Adélie est coupée … il y a plusieurs façons de régler ce problème. Nous allons simplement positionner les étiquettes à l’intérieur des barres, augmenter la taille des caractères et colorer le texte en blanc pour le rendre plus lisible.\r\n\r\n\r\n# Barplot + geom_text() + texte dans les barres\r\nggplot(data = pingouins,\r\n       mapping = aes(x = espece,\r\n                     fill = espece)) +\r\n  geom_bar(show.legend = FALSE) +\r\n  geom_text(aes(label = ..count..),\r\n            stat = \"count\",\r\n            vjust = 1.5,\r\n            colour = \"white\",\r\n            size = 5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nComme vous pouvez le voir, les espèces sont placées le long de l’axe x par ordre alphabétique. Nous préférerions qu’elles soient triées par ordre décroissant de nombre de pingouins. Nous allons voir trois façons de procéder :\r\n1) créer un objet intermédiaire : approche à éviter car elle ajoute un objet dans l’environnement et n’est pas dynamique, c’est-à-dire que le code ne sera pas utilisable pour d’autres cas de figure.\r\n\r\n\r\n# Tri avec création d'un objet intermédiaire\r\n\r\npingouins_tri <- pingouins %>% \r\n  mutate(espece = factor(espece,\r\n                         levels = c(\"Adelie\", \"Gentoo\", \"Chinstrap\")))\r\n\r\nggplot(data = pingouins_tri,\r\n       mapping = aes(x = espece,\r\n                     fill = espece)) +\r\n  geom_bar(show.legend = FALSE) +\r\n  geom_text(aes(label = ..count..),\r\n            stat = \"count\",\r\n            vjust = 1.5,\r\n            colour = \"white\",\r\n            size = 5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n2) modifier l’objet pingouins dans la fonction ggplot : cette approche utilise la fonction mutate() du package dplyr pour créer le facteur espece. Le code sera ré-utilisable et ne crée pas de nouvel objet dans l’environnement. Il nous faut par contre déterminer les niveaux du facteur avec levels().\r\n\r\n\r\n# Tri dans la fonction ggplot() à l'aide de mutate()\r\n\r\nggplot(data = mutate(pingouins,\r\n                     espece = factor(espece,\r\n                                     levels = c(\"Adelie\", \"Gentoo\", \"Chinstrap\"))),\r\n       mapping = aes(x = espece,\r\n                     fill = espece)) +\r\n  geom_bar(show.legend = FALSE) +\r\n  geom_text(aes(label = ..count..),\r\n            stat = \"count\",\r\n            vjust = 1.5,\r\n            colour = \"white\",\r\n            size = 5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n3) utiliser les fonctionnalités du package forcats : ce package, qui fait partie du Tidyverse, permet d’effectuer des opérations sur des facteurs. C’est l’approche la plus dynamique : R transforme une variable en facteur et détermine automatiquement les niveaux. Nous n’avons donc plus besoin de préciser les niveaux. Nous pouvons par exemple trier les niveaux d’un facteur par ordre d’apparition avec fct_inseq(), ou par ordre de nombre d’observations à l’aide de fct_infreq().\r\n\r\n\r\n# Tri dans la fonction ggplot() à l'aide des fonctionnalites du package forcats\r\n\r\nggplot(data = mutate(pingouins,\r\n                     espece = fct_infreq(espece)),\r\n       mapping = aes(x = espece,\r\n                     fill = espece)) +\r\n  geom_bar(show.legend = FALSE) +\r\n  geom_text(aes(label = ..count..),\r\n            stat = \"count\",\r\n            vjust = 1.5,\r\n            colour = \"white\",\r\n            size = 5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\n\r\nComme nous l’avions fait pour les boxplots, nous pouvons changer l’orientation des barres. Nous allons modifier quelques éléments du code :\r\nen basculant les espèces le long de l’axe y, l’espèce ayant le plus grand nombre de pingouins va se retrouver en bas du graphique. En effet, la variable espece étant un facteur avec des niveaux ordonnés, le premier niveau du facteur se retrouve au plus près de l’origine de l’axe : à gauche si les barres sont orientées verticalement, en bas si elles sont orientées horizontalement. Pour inverser l’ordre des niveaux, nous utilisons fct_rev().\r\nnous modifions l’alignement des étiquettes en remplaçant vjust par hjust\r\nnous réduisons la largeur des barres à l’aide du paramètre width\r\n\r\n\r\n# Barplot horizontal\r\n\r\nggplot(data = mutate(pingouins,\r\n                     espece = fct_rev(fct_infreq(espece))),\r\n       mapping = aes(x = espece,\r\n                     fill = espece)) +\r\n  geom_bar(width = 0.75,\r\n           show.legend = FALSE) +\r\n  geom_text(aes(label = ..count..),\r\n            stat = \"count\",\r\n            hjust = 1.5,\r\n            colour = \"white\",\r\n            size = 5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  coord_flip() +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\n\r\nUne note sur l’utilisation du pipe %>%\r\nNous pouvons également utiliser le pipe %>% que nous avions vu dans le tutoriel sur le Tidyverse pour enchaîner les opérations de tri puis la création du graphique.\r\nCette façon de procéder permet, quand nous manipulons un jeu de données (ajout d’une colonne par exemple), de s’assurer que nous n’avons pas fait d’erreur avant de générer le graphique, le tout sans avoir besoin de créer d’objet intermédiaire. L’utilisation du pipe permet également de bénéficier de l’auto-complétion à l’aide de la touche Tab, ce qui est plutôt appréciable quand nos variables portent des noms complexes ou que le code contient de nombreux paramètres.\r\n\r\n\r\n# Utilisation du pipe %>%\r\n\r\npingouins %>% \r\n  mutate(espece = fct_rev(fct_infreq(espece))) %>% \r\n  ggplot(mapping = aes(x = espece,\r\n                       fill = espece)) +\r\n  geom_bar(width = 0.75,\r\n           show.legend = FALSE) +\r\n  geom_text(aes(label = ..count..),\r\n            stat = \"count\",\r\n            hjust = 1.5,\r\n            colour = \"white\",\r\n            size = 5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  coord_flip() +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nGraphiques multiples\r\nQuel est le rapport entre la longueur du bec et la longueur des ailes ?\r\nNous pouvons créer un nuage de points avec les trois espèces sur un même graphique, comme nous l’avons fait jusqu’ici :\r\n\r\n\r\n# Scatter plot : 1 graphique pour les 3 especes\r\n\r\npingouins %>% \r\n  mutate(espece = fct_rev(fct_infreq(espece))) %>% \r\n  ggplot(mapping = aes(x = espece,\r\n                       fill = espece)) +\r\n  geom_bar(width = 0.75,\r\n           show.legend = FALSE) +\r\n  geom_text(aes(label = ..count..),\r\n            stat = \"count\",\r\n            hjust = 1.5,\r\n            colour = \"white\",\r\n            size = 5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  coord_flip() +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nNous souhaitons maintenant visualiser ces données en sépérant les graphiques par espece et par ile.\r\nNous pourrions pour cela créer séparément les graphiques à l’aide de la fonction filter(). ggplot2 possède deux fonctions qui le font directement : facet_wrap() et facet_grid().\r\nfacet_wrap()\r\nNous allons simplement ajouter une couche à notre graphique précédent en précisant quelle variable sert à séparer les données (à l’aide d’un tilde ~). Nous modifions également le thème pour rendre les noms des espèces plus lisibles :\r\n\r\n\r\n# facet_wrap() : 1 graphique par espece\r\nggplot(data = pingouins,\r\n       mapping = aes(x = aile_lngr_mm,\r\n                     y = bec_lngr_mm)) +\r\n  geom_point(aes(colour = espece),\r\n             size = 3,\r\n             alpha = 0.5,\r\n             show.legend = FALSE) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Rapport entre la longueur du bec et la longueur des ailes\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"Longueur de l'aile (mm)\",\r\n       y = \"Longueur du bec (mm)\") +\r\n  facet_wrap(~espece) +\r\n  theme_light()\r\n\r\n\r\n\r\n\r\nNous pouvons modifier l’orientation des graphiques à l’aide du paramètre dir = ... (par défaut h, v pour des graphiques orientés verticalement).\r\nNous pouvons également déplacer l’étiquette de titre (noms des espèces dans notre cas) avec le paramètre strip.position = ... (par défaut top, peut prendre les valeurs right, bottom ou left) :\r\n\r\n\r\n# facet_wrap() : 1 graphique par espece + paramètres\r\nggplot(data = pingouins,\r\n       mapping = aes(x = aile_lngr_mm,\r\n                     y = bec_lngr_mm)) +\r\n  geom_point(aes(colour = espece),\r\n             size = 3,\r\n             alpha = 0.5,\r\n             show.legend = FALSE) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                 \"Chinstrap\" = \"purple\",\r\n                                 \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Rapport entre la longueur du bec et la longueur des ailes\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"Longueur de l'aile (mm)\",\r\n       y = \"Longueur du bec (mm)\") +\r\n  facet_wrap(~espece,\r\n             dir = \"v\",\r\n             strip.position = \"right\") +\r\n  theme_light()\r\n\r\n\r\n\r\n\r\nCommençons par placer les données des trois espèces sur un seul graphique :\r\nLa fonction facet_wrap() s’utilise simplement en précisant quelle variable va nous servir à séparer nos données (la variable espèce dans notre cas), précédée d’un tilde ~ :\r\n\r\n\r\n# Rapport entre la longueur du bec et la longueur des ailes - 1 graphique par espèce\r\nggplot(data = pingouins,\r\n       mapping = aes(x = aile_lngr_mm,\r\n                     y = bec_lngr_mm)) +\r\n  geom_point(aes(colour = espece),\r\n             show.legend = FALSE) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Rapport entre la longueur du bec et la longueur des ailes\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"Longueur de l'aile (mm)\",\r\n       y = \"Longueur du bec (mm\") +\r\n  facet_wrap(~espece) +\r\n  theme_minimal()\r\n\r\n\r\n\r\n\r\nPour simplifier la lecture de ce graphique, nous pouvons utiliser un autre thème :\r\n\r\n\r\n# Changer le thème\r\nggplot(data = pingouins,\r\n       mapping = aes(x = aile_lngr_mm,\r\n                     y = bec_lngr_mm)) +\r\n  geom_point(aes(colour = espece),\r\n             show.legend = FALSE) +\r\n  scale_colour_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Rapport entre la longueur du bec et la longueur des ailes\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"Longueur de l'aile (mm)\",\r\n       y = \"Longueur du bec (mm\") +\r\n  facet_wrap(~espece) +\r\n  theme_light()\r\n\r\n\r\n\r\n\r\nExporter un graphique\r\nJusqu’à présent, nos différents graphiques apparaissaient dans le panneau Viewer de RStudio, mais n’étaient pas sauvegardés.\r\nIl existe plusieurs façons d’exporter un graphique :\r\n- A partir du panneau Viewer : en cliquant sur Export, vous aurez le choix entre sauvegarder votre graphique sous forme d’image ou de fichier pdf, ou vous pourrez le copier dans le presse-papiers (par exemple pour le coller dans un document). Nous allons le sauvegarder sous forme d’image.\r\n\r\n\r\n\r\nVous aurez alors le choix entre plusieurs formats (.png, .jpeg, …). Vous pourrez également redimensionner votre graphique (en conservant ou non le ratio des dimensions), choisir le dossier de destination et renommer votre fichier (le nom proposé par défaut n’est pas très explicite …).\r\n\r\n\r\n\r\n\r\n- En utilisant la fonction ggsave() : il vous faudra d’abord assigner votre graphique dans un objet. R est ce qu’on appelle un langage orienté objet**, ce qui veut dire que tout ce que vous manipulez dans votre session R (les fichiers importés, les transformations, les fonctions, et même les graphiques !) sont stockés dans la mémoire vive sous forme d’objet.\r\nVous pouvez simplement ajouter un nom d’objet et une flèche d’assignation devant le code ayant servi à générer votre dernier graphique : barplot_especes <- ggplot(.... Votre graphique (y compris toutes les couches ajoutées et les paramètres) est stocké dans l’objet barplot_especes. Vous n’aurez par contre pas d’aperçu de votre graphique dans le panneau Viewer comme c’était le cas jusque là. Vous pouvez simplement appeler l’objet créé pour l’afficher, ou entourer l’ensemble de ce code par des parenthèses pour effectuer les deux opérations à la fois : stocker le graphique dans un objet et l’afficher dans le panneau Viewer.\r\n\r\n\r\n# Assigner le bar plot à l'obet barplot_especes et l'afficher\r\n(barplot_especes <- pingouins %>% \r\n   mutate(espece = fct_rev(fct_infreq(espece))) %>% \r\n   ggplot(aes(x = espece,\r\n              fill = espece)) +\r\n   geom_bar(show.legend = FALSE,\r\n            width = 0.5) +\r\n   scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                \"Chinstrap\" = \"purple\",\r\n                                \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n   coord_flip() +\r\n   theme_minimal()\r\n)\r\n\r\n\r\n\r\n\r\nCréons maintenant un répértoire figs/ dans notre répertoire de travail (à l’aide de New Folder dans l’onglet Files dans RStudio) et sauvegardons notre graphique :\r\n\r\n\r\nggsave(\"figs/barplot_especes.png\", barplot_especes, dpi = 320, width = 12, height = 6)\r\n\r\n\r\n\r\nDécortiquons cette commande pour comprendre sa syntaxe :\r\n**figs/barplot_especes.png : répertoire de destination et nom sous lequel sauvegarder le graphique\r\n**barplot_especes : nom de l’objet dans lequel le graphique est stocké. Vous pouvez également utiliser la fonction last_plot() pour sauvegarder le dernier graphique.\r\n-dpi = 320 : résolution de l’image\r\n-width = 12 : largeur de l’image\r\n-height = 6 : hauteur de l’image\r\nIl existe d’autres paramètres, n’hésitez pas explorer l’aide de la fonction à l’aide de la commande ?ggsave. Vous pouvez essayer différentes options et valeurs pour voir le résultat.\r\nOuvrez le fichier barplot_especes.png et comparez ce fichier avec le visuel affiché dans votre session RStudio. Il n’est pas rare d’avoir quelques surprise ! La taille des lettres peut par exemple être plus petite dans le fichier exporté que dans l’aperçu RStudio. Il est toujours utile d’exporter son graphique et de vérifier le rendu pour rectifier les paramètres si nécessaire.\r\n\r\n\r\n\r\nAméliorer ses graphiques\r\nNous avons vu comment créer les principaux types de graphiques ainsi que certains paramètres permettant de modifier leur apparence. Il existe énormément de paramètres permettant de modifier nos graphiques pour les rendre plus attractifs. Les possibilités sont pour ainsi dire infinies !\r\n\r\nLa suite de ce tutoriel vous donnera quelques éléments pour améliorer vos graphiques, n’hésitez pas à aller voir la section Liens du blog pour trouver d’autres ressources qui vous aideront à creuser encore davantage les possibilités de ggplot2.\r\nModifier l’arrière-plan\r\nCommençons par un paramètre assez évident, à savoir la couleur de l’arrière-plan. Les thèmes prédéfinis dans ggplot2 vous donnent quelques possibilités, mais vous pouvez en réalité choisir n’importe quelle couleur, pour peu que vous ayiez son nom ou son code hexadécimal.\r\nNous allons reprendre le barplot du nombre de pingouins par espèce et y apporter des modifications, en montrant le résultat étape par étape.\r\nLe paramètre theme() va vous permettre d’ajuster tous les paramètres de votre graphique (et la liste est très longue !).\r\n\r\nVotre graphique se compose de deux grandes parties :\r\nle “panel” qui contient les éléments de visualisation (le graphique lui-même)\r\nle plot qui contient tout ce qui est autour : titre, légende, titres des axes, …\r\nNous allons commencer par modifier la couleur de l’arrière-plan de la zone du graphique, à l’aide du paramètre panel.background(). Nous allons dans ce paramètre préciser la couleur de l’intérieur et du contour de la zone du graphique (comme nous l’avions fait plus haut en modifiant la forme et les couleurs des points) à l’aide des paramètres fill et colour au sein d’un argument element_rect() :\r\n\r\n\r\n# Modifier la couleur de l'arrière-plan de la zone du graphique\r\npingouins %>% \r\n   mutate(espece = fct_rev(fct_infreq(espece))) %>% \r\n   ggplot(aes(x = espece,\r\n              fill = espece)) +\r\n   geom_bar(show.legend = FALSE,\r\n            width = 0.5) +\r\n   scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                \"Chinstrap\" = \"purple\",\r\n                                \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n   coord_flip() +\r\n   theme_minimal() +\r\n  theme(panel.background = element_rect(fill = \"#1d3557\", colour = NA))\r\n\r\n\r\n\r\n\r\nPour modifier la couleur de l’arrière-plan de la zone autour du graphique, nous procédons de la même façon à l’aide du paramètre plot.background() :\r\n\r\n\r\n# Modifier la couleur de l'arrière-plan de la zone autour du graphique\r\npingouins %>% \r\n   mutate(espece = fct_rev(fct_infreq(espece))) %>% \r\n   ggplot(aes(x = espece,\r\n              fill = espece)) +\r\n   geom_bar(show.legend = FALSE,\r\n            width = 0.5) +\r\n   scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                                \"Chinstrap\" = \"purple\",\r\n                                \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n   coord_flip() +\r\n   theme_minimal() +\r\n  theme(panel.background = element_rect(fill = \"#1d3557\", colour = NA),\r\n        plot.background = element_rect(fill = \"#1d3557\", colour = NA))\r\n\r\n\r\n\r\n\r\nModifier la grille\r\nCertaines lignes de la grille peuvent devenir inutiles. Dans notre cas, les lignes horizontales de la grille ne sont pas nécessaires à la compréhension du graphique. Nous allons pouvoir modifier ces éléments à l’aide des paramètres panel.grid. :\r\npanel.grid : modifier toutes les lignes\r\npanel.grid.major : modifier les lignes principales\r\npanel.grid.minor : modifier les lignes secondaires\r\npanel.grid.major.x : modifier les lignes principales de l’axe x\r\npanel.grid.major.y : modifier les lignes principales de l’axe y\r\npanel.grid.minor.x : modifier les lignes secondaires de l’axe x\r\npanel.grid.minor.y : modifier les lignes secondaires de l’axe y\r\n\r\nNous procédons de la façons suivante :\r\n1) Supprimer toutes les lignes secondaires : panel.grid.minor = element_blank()\r\n2) Modifier les lignes principales de l’axe en lignes pointillées : panel.grid.major.x = element_line(linetype = \"dotted)\r\n3) Supprimer les lignes principales de l’axe y : panel.grid.major.y = element_blank()\r\n\r\n\r\n# Modifier la grille\r\npingouins %>% \r\n  mutate(espece = fct_rev(fct_infreq(espece))) %>% \r\n  ggplot(aes(x = espece,\r\n             fill = espece)) +\r\n  geom_bar(show.legend = FALSE,\r\n           width = 0.5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  coord_flip() +\r\n  theme_minimal() +\r\n  theme(panel.background = element_rect(fill = \"#1d3557\", colour = NA),\r\n        plot.background = element_rect(fill = \"#1d3557\", colour = NA),\r\n        panel.grid.minor = element_blank(),\r\n        panel.grid.major.x = element_line(linetype = \"dotted\"),\r\n        panel.grid.major.y = element_blank())\r\n\r\n\r\n\r\n\r\nLe texte\r\nL’arrière-plan plus sombre rend le texte difficilement lisible. Nous pouvons modifier la couleur et la taille du texte utilisé dans le titre, le sous-titre, les titres des axes et les étiquettes de axes.\r\nPlusieurs paramètres permettent de modifier du texte :\r\nfamily : police de caractères\r\ncolour : couleur du texte\r\nsize : taille du texte (valeurs numériques)\r\nhjust : alignement horizontal du texte\r\nvjust : alignement vertical du texte\r\n\r\n0 (à gauche), 0.5 (centre) ou 1 (droite)\r\nCes paramètres peuvent être appliqués séparément au titre, au sous-titre, aux titres des axes et aux étiquettes des axes.\r\nLe package showtext() permet d’utiliser des polices Google fonts dans nos graphiques, n’hésitez pas à fouiller pour trouver celle qui vous convient !\r\nInstaller et charger le package showtext :\r\n\r\n\r\n# Installer et charger le package showtext\r\ninstall.packages(\"showtext\")\r\nlibrary(showtext)\r\n\r\n\r\n\r\nNous allons utiliser la police Righteous :\r\n\r\n\r\n\r\n\r\n\r\nfont_add_google(\"Righteous\", \"Righteous\")\r\nshowtext_auto()\r\n\r\n\r\n\r\nNous pouvons maintenant modifier les paramètres en procédant de la manière suivante :\r\nmodifier la police, la taille, la couleur et l’alignement du titre : plot.title = element_text(family = \"Righteous\", colour = \"white\", size = 25, hjust = 0.5)\r\nmodifier la police, la taille, la couleur et l’alignement du sous-titre : plot.subtitle = element_text(family = \"Righteous\", colour = \"white\", size = 15, hjust = 0.5)\r\nmodifier la police, la taille et la couleur du texte des axes : axis.text = element_text(family = \"Righteous\", colour = \"white\", size = 12)\r\n\r\n\r\n# Modifier le texte\r\npingouins %>% \r\n  mutate(espece = fct_rev(fct_infreq(espece))) %>% \r\n  ggplot(aes(x = espece,\r\n             fill = espece)) +\r\n  geom_bar(show.legend = FALSE,\r\n           width = 0.5) +\r\n  scale_fill_manual(values = c(\"Adelie\" = \"darkorange\",\r\n                               \"Chinstrap\" = \"purple\",\r\n                               \"Gentoo\" = \"cyan4\")) +\r\n  labs(title = \"Nombre de pingouins\",\r\n       subtitle = \"pour trois espèces de l'archipel Palmer\",\r\n       x = \"\",\r\n       y = \"\") +\r\n  coord_flip() +\r\n  theme_minimal() +\r\n  theme(panel.background = element_rect(fill = \"#1d3557\", colour = NA),\r\n        plot.background = element_rect(fill = \"#1d3557\", colour = NA),\r\n        panel.grid.minor = element_blank(),\r\n        panel.grid.major.x = element_line(linetype = \"dotted\"),\r\n        panel.grid.major.y = element_blank(),\r\n        plot.title = element_text(family = \"Righteous\", colour = \"white\",\r\n                                  size = 25, hjust = 0.5),\r\n        plot.subtitle = element_text(family = \"Righteous\", colour = \"white\",\r\n                                     size = 15, hjust = 0.5),\r\n        axis.text = element_text(family = \"Righteous\", colour = \"white\",\r\n                                 size = 12))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/visualiser-donnees-ggplot2/img/ggplot2_blank.png",
    "last_modified": "2022-06-28T11:34:00+02:00",
    "input_file": {}
  },
  {
    "path": "posts/datatable/",
    "title": "data.table",
    "description": "Importer formater et manipuler vos données: data.table vs tidyverse.",
    "author": [
      {
        "name": "Pauline Lasserre-Zuber",
        "url": "https://ourcodingclub.github.io/tutorials/datatable"
      }
    ],
    "date": "2022-06-20",
    "categories": [
      "R",
      "data.table",
      "tidyverse"
    ],
    "contents": "\n\nContents\nIntroduction\n1-IMPORT DE TABLES FORMAT LONG: readr vs fread\n2-CALCULS SUR LES COLONNES\n3-CREER UNE NOUVELLE COLONNE SELON CRITERES\n4-SELECTIONNER DES COLONNES\n5-JOINDRE DES TABLES\n6-EXPORTATION DE TABLE\n7-IMPORT DE TABLE FORMAT LARGE\n8-FORMATAGE DES DONNEES\n\nIntroduction\n\n\n\n\nPour des tables de données de taille petite et moyenne (inférieure à 1 Go ou moins d’un million d’observations), il est recommandé d’utiliser le package dplyr. Pour des tables de données de grande taille (plus de 1 Go ou plus d’un million d’observations), il est recommandé d’utiliser le package data.table\nUn des atouts fondamentaux de data.table est sa syntaxe compacte qui lui vaut sa rapidité: data.table ne manipule que les colonnes mentionnées dans l’opérateur […], ce qui réduit le temps de traitement des données.\nLa forme générale de l’opérateur […] est la suivante: DT[i, j, by]: on part du data.table DT, on sélectionne certaines lignes avec i, puis on calcule j pour chaque groupe défini par by. Si on fait un parallèle avec SQL, i correspond au WHERE, j au SELECT et by au GROUP BY. La fonction […] présente deux grands avantages: pas de préfixe DT$ pour se référer aux variables à l’intérieur de […] et sa concision.\nLes fonctions setDT() et as.data.table() convertissent un data.frame en data.table\nLes data.tables sont simplement des data.frames particuliers, donc on peut normalement leur appliquer toutes les méthodes valables pour les data.frames. En particulier, on peut utiliser avec data.table toutes les fonctions des packages habituellement associés à dplyr : stringr pour le maniement de chaînes de caractères, etc.\n\nSommaire :\n1. IMPORT DE TABLES FORMAT LONG: readr vs fread : setup, import table 1, import table 2, sélection des données à importer, presentation des données\n2. CALCULS SUR LES COLONNES : calculs par groupe selon critères, enchainer les calculs\n3. CREER UNE NOUVELLE COLONNE SELON CRITERES\n4. SELECTIONNER DES COLONNES: tydiverse, data.table\n5. JOINDRE DES TABLES: Rbase, tydiverse, data.table avec ou sans index\n6. EXPORTATION DE TABLE: Rbase, tydiverse, data.table\n7. IMPORT DE TABLE FORMAT LARGE: tydiverse, data.table\n8. FORMATAGE DES DONNEES: tydiverse, data.table\n\n1-IMPORT DE TABLES FORMAT LONG: readr vs fread\nSetup\n\n\n# chargement des packages\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\n\nlibrary(data.table)\n\n#localisation donnees entree\n#dirin<-\"C:/Users/plasserre/Documents/R_workshops/workshop_data.table/inputs/\"\n#setwd(dirin)\n\n\n\n\nImport table 1\n\n\n# package readr de la suite tidyverse\nstart.time <- Sys.time()\nd=read_tsv(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", col_names=T)\ntime.tidy <- Sys.time() - start.time\n\n\n\n\n\n#package data.table\n##info systeme:\nnames(s <- Sys.getenv())\nSys.getenv(\"NUMBER_OF_PROCESSORS\")\nSys.getenv(\"PROCESSOR_LEVEL\")\nSys.getenv(\"OMP_THREAD_LIMIT\")\nSys.setenv(\"OMP_THREAD_LIMIT\"=4)\nSys.getenv(\"OMP_THREAD_LIMIT\")\n\n\n##nThread=1\nsetDTthreads(threads=1, restore_after_fork=TRUE)\ngetDTthreads(verbose = getOption(\"datatable.verbose\"))\n\nstart.time <- Sys.time()\ndt=fread(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\",\n         nThread=1, sep=\"\\t\", header=TRUE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE)\ntime.dt1 <- Sys.time() - start.time\ntime.dt1\ntime.tidy\n\n##nThread=4\nsetDTthreads(threads=6, restore_after_fork=TRUE)\ngetDTthreads(verbose = getOption(\"datatable.verbose\"))\n\nstart.time <- Sys.time()\ndt=fread(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", \n         nThread=4, sep=\"\\t\", header=TRUE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE)\ntime.dt4 <- Sys.time() - start.time\ntime.dt4\ntime.tidy\n\n#definition d'un deuxieme seprarteur (sep2) possible !!! :))\n#NB: option stringsAsFactors = TRUE peut ralentir sensiblement l’importation des donnees\n\n\n\n\nImport table 2\n\n\n#package readr de la suite tidyverse\nstart.time <- Sys.time()\nfa=read_tsv(\"Tae.Chinese_Spring.refSeqv2.1.ISBPs_fasta.txt\", col_names=F)\ntime.tidy <- Sys.time() - start.time\n\ncolnames(fa)=c(\"read_id\",\"seq\")\n\n#package data.table  ---> nThread \nstart.time <- Sys.time()\nfadt=fread(\"Tae.Chinese_Spring.refSeqv2.1.ISBPs_fasta.txt\",\n           nThread=4, sep=\"\\t\", colClasses=c(\"character\", \"character\"), header=FALSE,\n           encoding = \"UTF-8\", showProgress=TRUE)\ntime.dt4 <- Sys.time() - start.time\ntime.dt4\ntime.tidy\n\n\n\n\nSélection des données à importer\n\n\n# #package readr de la suite tidyverse\nstart.time <- Sys.time()\nd=read_tsv(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", col_names=T,\n           col_select = -\"query_length\")\ntime.tidy <- Sys.time() - start.time\n\n\n#pour selectionner des colonnes à importer: option \"clo_select\" avec ou sans -\n#pour importer une portion de table: option \"skip\" et \"n_max\n\n\n#package data.table\nstart.time <- Sys.time()\ndt=fread(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", \n         nThread=4, sep=\"\\t\", header=TRUE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE,\n         drop=\"query_length\")\ntime.dt4 <- Sys.time() - start.time\ntime.dt4\ntime.tidy\n\n#pour selectionner des colonnes à importer: option \"clo_select\" avec ou sans -\n#pour importer une portion de table: option \"skip\" + \"nrows\"\n\n\n\n ## Presentation des données {#presentation}\n\n\n#suite tidyverse\nd\nfa\n\ndf=data.frame(d)\nfadf=data.frame(fa)\n\n#package data.table\ndt\nfadt\ncolnames(fadt)=c(\"read_id\",\"seq\")\n\noptions(\"datatable.print.keys\" = TRUE, \"datatable.print.class\" = TRUE)\ndt\n\n\n\n\n2-CALCULS SUR LES COLONNES\nCalculs par groupe selon critères\n\n\n# R base\nstart.time <- Sys.time()\nhead(df)\naggregate(df[df[[\"alignemnt_length\"]]==150, \"mapq\"],\n          by=list(df[df[[\"alignemnt_length\"]]==150, \"missmatches\"]),\n          FUN=mean)\nSys.time() - start.time\n\n#suite tidyverse\nstart.time <- Sys.time()\nprint(d %>%\n  dplyr::filter(alignemnt_length==150)%>%\n  dplyr::group_by(missmatches)%>%\n  dplyr::summarise(mean(mapq)),\n  n=100)\nSys.time() - start.time\n\n\n#package data.table\nstart.time <- Sys.time()\ndt[alignemnt_length==150, mean(mapq), by = missmatches]\nSys.time() - start.time\n\n\n\n ## Enchainer les calculs {#arrange}\nDplyr utilise l’opérateur pipe %>%.\nAvec data.table, il suffit d’accoler les opérateurs []: dt[opération 1][opération 2][opération 3][…]\n\n\n#suite tidyverse\nprint(d %>%\n        dplyr::filter(alignemnt_length==150) %>%\n        dplyr::group_by(missmatches) %>%\n        dplyr::summarise(mean(mapq))%>%\n        arrange(`mean(mapq)`),\n      n=100)\n\n#package data.table\ndt[alignemnt_length==150, mean(mapq), by = missmatches][order(missmatches)]\n\n\n\n\n3-CREER UNE NOUVELLE COLONNE SELON CRITERES\n\n\n#suite tidyverse\n##dim ligne --NON-- constante, dim colonne +1 : on cree la colonne nomee \"keep\"\nd_filt=d %>%\n  filter(alignemnt_length==150 & mapq==60)%>%\n  mutate(keep=\"OK\")\nd_filt\n\n##dim ligne constante, dim colonne +1 : on cree la colonne nomee \"keep\"\nstart.time <- Sys.time()\nd=d %>%\n  mutate(keep=if_else(alignemnt_length==150 & mapq==60,\"OK\",\"NA\"))\nSys.time() - start.time\n\nd\n#NB: assignation necessaire\n\n\n#package data.table\n##utilise beaucoup moins de memoire vive\n##la fonction := s’appelle “assignation par reference”, elle peut prendre des arguments entre parentheses`:=`()\n\n##dim ligne --NON-- constante, dim colonne +1\ndt_filt=dt[alignemnt_length==150 & mapq==60][, keep:= \"OK\"]\ndt_filt\n\n##dim ligne constante, dim colonne +1\nstart.time <- Sys.time()\ndt[alignemnt_length==150 & mapq==60, keep:= \"OK\"]\n#NB: pas d'assignation, table modifiee par reference\nSys.time() - start.time\n\ndt[, keep:= \"OK\"][alignemnt_length!=150 | mapq!=60, keep:= NA]\n\n\n\n\n4-SELECTIONNER DES COLONNES\ntydiverse\n\n\n#suite tidyverse\nd%>%select(read_id, missmatches, mapq)\n\n#package data.table\ndt[, .(read_id, missmatches, mapq)]   #NB: .() est un alias pour \"list()\"\n\ndt[, .SD, .SDcols=c(\"read_id\", \"missmatches\", \"mapq\")] #ecriture a combiner avec lapply\n#SD pour Subset of Data: les colonnes listees seront aliasees par .SD avec la dimension .SDcols\n#et par defaut, toutes les colonnes sont traitees\n\n\n\n ## data.table {#data.table1}\n\n\n# \n\n\n\n\n5-JOINDRE DES TABLES\nRbase\n\n\n # R base\nstart.time <- Sys.time()\n#df_join=base::merge(df,fadf, by=\"read_id\", all.x=TRUE)\nSys.time() - start.time\n#####Time difference of 1.373174 mins\n\n\n\n ## tydiverse {#tidyverse2}\n\n\n#suite tidyverse\nstart.time <- Sys.time()\nd_join=d%>%left_join(fa)   #NB: une seule var key commune, nul besoin de preciser la var de jointure\n#sinon: d_join=d%>%left_join(y=fa, by=\"read_id\")\nSys.time() - start.time\n\n\n\n ## data.table avec ou sans index {#data.table2}\n\n\n#package data.table\n##avec merge, meme ecriture qu'avec la fonction de R base\n\nstart.time = Sys.time()\ndt_join=merge(dt,fadt, by=\"read_id\", all.x=T)\ntime.dt_sansindex = Sys.time() - start.time\n\nstart.time = Sys.time()\ndt_join=dt[fadt, on=\"read_id\", nomatch=NULL]\nSys.time() - start.time\n\n##indexation de tables: accelere les combinaisons de donnees\nsetkey(dt, read_id)\nsetkey(fadt, read_id)\n\nstart.time = Sys.time()\ndt_join=merge(dt,fadt, by=\"read_id\", all.x=T)\ntime.dt_avecindex = Sys.time() - start.time\ntime.dt_sansindex\ntime.dt_avecindex\n\nkey(dt)\nsetkey(dt, NULL)\nkey(dt)\n\n\n\n\n6-EXPORTATION DE TABLE\nRbase\n\n\n#R base\nstart.time <- Sys.time()\n#write.table(df_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA.TAB\", col.names=T)\nSys.time() - start.time\n#Time difference of 1.977623 mins\n\n\n\n ## tydiverse {#tidyverse3}\n\n\n#suite tidyverse package readr\nstart.time <- Sys.time()\nwrite_tsv(d_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA.TAB\", col_names=T)\nSys.time() - start.time  # ~20 à 30sec\n\n\n\n ## data.table {#data.table3}\n\n\n#package data.table\nstart.time <- Sys.time()\nfwrite(dt_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA.TAB\", col.names=T)\nSys.time() - start.time  # moins de 2 secondes\n\n\n\n\n7-IMPORT DE TABLE FORMAT LARGE\ntydiverse\n\n\n# TRANSPOSITION \nmat_join=as.matrix(dt_join)\ndim(mat_join)\nhead(mat_join, n=1)\ncolnames(mat_join)\n\ntmat_join=as.matrix(t(mat_join))\ndim(tmat_join)\nhead(tmat_join[,c(1,2,3,4,5)], n=9)\ntmat_join=data.table(tmat_join)\n\nfwrite(tmat_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA_transposed_dt.TAB\", sep=\"\\t\", col.names=F)\n\n#package readr de la suite tidyverse\nstart.time <- Sys.time()\n#d_trans=read_tsv(\"ISBP_REFSEQV2_vs_RENAN_with_FASTA_transposed_dt.TAB\", col_names=F)\ntime.tidy <- Sys.time() - start.time ## tres tres long\n\n\n\n ## data.table {#data.table4}\n\n\n#package data.table\nstart.time <- Sys.time()\ndt_trans=fread(\"ISBP_REFSEQV2_vs_RENAN_with_FASTA_transposed_dt.TAB\", \n         nThread=4, sep=\"\\t\", header=FALSE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE)\ntime.dt <- Sys.time() - start.time\ntime.dt # ~16 secondes\ntime.tidy\n\n\n\n\n8-FORMATAGE DES DONNEES\ntydiverse\n\n\n# mutate sur une colonne avec tidyverse\nstart.time <- Sys.time()\nd_joinU=d_join %>% head(5)%>%mutate(seq=str_replace_all(seq,\"T\",\"U\"))\ntime.tidy <- Sys.time() - start.time\n\n### mutate(across) sur toutes les colonnes \ntmat_d_join=tibble(tmat_join[,1:100000])\n\nstart.time <- Sys.time()\ntmat_d_joinU=tmat_d_join %>% mutate(across(everything(), ~gsub(\"T\",\"U\",.)))\ntime.tidy <- Sys.time() - start.time\ntime.tidy\n\nhead(tmat_d_joinU[,c(1,2,3,4,5)], n=9)\n\n\n\n\ndata.table\n\n\n# str_replace sur une colonne\nstart.time <- Sys.time()\ndt_joinU=dt_join[1:5,][,seq:=str_replace_all(seq,\"T\",\"U\")]\ntime.dt <- Sys.time() - start.time\ntime.dt\ntime.tidy\n\n### lapply .SD .SDcols sur 5 colonnes\ncols=c(\"V1\",\"V2\",\"V3\",\"V4\",\"V5\")\ntmat_dt_joinU=tmat_dt_join[,(cols):=lapply(.SD, function(x) gsub(\"T\",\"U\",as.character(x))), .SDcols=cols]\nhead(tmat_dt_joinU[,c(1,2,3,4,5)], n=9)\n\n### lapply .SD .SDcols sur toutes les colonnes \ncols=c(\"V1\",\"V2\",\"V3\",\"V4\",\"V5\")\nstart.time <- Sys.time()\ntmat_dt_joinU=lapply(tmat_dt_join, function(x) gsub(\"T\",\"U\",as.character(x)) )\ntime.dt <- Sys.time() - start.time\ntime.dt\n\nhead(tmat_dt_joinU[,c(1,2,3,4,5)], n=9)\n\n\n\n\nRéférences UtilitR\n\n\n\n",
    "preview": "posts/datatable/img/battle.png",
    "last_modified": "2022-06-20T13:56:34+02:00",
    "input_file": {}
  },
  {
    "path": "posts/manipuler-donnees-tidyverse/",
    "title": "Manipulation de données",
    "description": "Manipuler et mettre en forme vos données à l'aide du Tidyverse.",
    "author": [
      {
        "name": "Sandra Angers-Blondin",
        "url": "https://ourcodingclub.github.io/tutorials/data-manip-intro"
      },
      {
        "name": "Jonathan Kitt (adaptation)",
        "url": {}
      }
    ],
    "date": "2022-05-20",
    "categories": [
      "R",
      "RStudio",
      "Données",
      "Tidyverse"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nManipuler des données avec dplyr\r\nMettre en forme des données à l’aide de tidyr\r\nDéfi\r\n\r\nCe tutoriel est adapté de Basic data manipulation et Efficient data manipulation du site Our Coding Club.\r\nIntroduction\r\n\r\n\r\n\r\nDessin de Allison Horst\r\n\r\nLes formats de nos données peuvent varier, et un format utile et pratique dans un cas précis ne le sera pas forcément dans un autre. La maîtrise des outils de manipulation et de mise en forme des données est donc essentielle !\r\n\r\nVoici le sommaire de ce tutoriel :\r\n\r\n1. Manipuler des données avec dplyr : renommer des variables, sélectionner des colonnes, filtrer des données, trier des données, créer de nouvelles colonnes, définir des groupes, calculer des statistiques, joindre des données\r\n2. Mettre en forme des données avec tidyr : format long, format large\r\n3. Défi\r\n\r\nVous pourrez trouver les fichiers utilisés dans ce tutoriel ainsi qu’un exemple de script en cliquant ici.\r\nVous pouvez revoir les bases de R et RStudio dans le tutoriel Premiers pas avec R.\r\n\r\nLe Tidyverse\r\nLe Tidyverse est un ensemble de packages permettant notamment d’importer des données (readr), de les manipuler (dplyr), de les mettre en forme (tidyr), de créer des graphiques (ggplot2), de manipuler des chaînes de caractères (stringr), de rédiger des rapports (rmarkdown), …\r\n\r\n\r\n\r\nDessin de Allison Horst\r\n\r\nCommençons par installer la suite Tidyverse (nous pourrions également installer séparément les packages que nous allons utiliser, dplyr et tidyr) :\r\n\r\n\r\n# Installer le Tidyverse\r\ninstall.packages(\"tidyverse\")\r\n\r\n\r\n\r\n\r\nManipuler des données avec dplyr\r\nLes fonctions du package dplyr sont nommées d’après l’action qu’elles accomplissent, ce qui rend leur utilisation assez intuitive.\r\nNous allons utiliser un jeu de données contenant des mesures de croissance annuelle de tiges d’arbrisseaux qui poussent dans des dunes de sable (Empetrum nigrum ou camarine noire). La distance à la mer de chaque individu est codée dans la variable catégorique “zone” : le chiffre 2 représente la zone la plus proche de la mer et le chiffre 7 la zone la plus éloignée de la mer.\r\nLa fonction read_csv() permet d’importer un fichier .csv depuis une page web :\r\n\r\n\r\n# Ateliers codons!\r\n# 02 - Manipulation de donnees\r\n# Lundi 30/05/2022\r\n\r\n# Charger le Tidyverse ----\r\n\r\nlibrary(tidyverse)\r\n\r\n# Definir le repertoire de travail ----\r\n\r\nsetwd(\"C-02-ManipulationDonnees\")\r\n\r\n# Importer les donnees ----\r\n\r\ncroissance <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/croissance.csv\")\r\n\r\n\r\n\r\n\r\nIl est toujours utile de visualiser vos données et leur structure :\r\n\r\n\r\n# Exploration rapide des donnees ----\r\n\r\nhead(croissance)  # affiche les premieres lignes\r\nstr(croissance)  # types des variables\r\nunique(croissance$Zone)  # affiche les valeurs distinctes de la variable Zone\r\ncroissance$Indiv  # affiche toutes les valeurs de la variable Indiv\r\nlength(unique(croissance$Indiv))  # affiche le nombre d'individus\r\n\r\n\r\n\r\n\r\nLorsque vous exécutez la commande head(croissance), vous pouvez remarquer dans la console la mention “A tibble”. Un tibble est un format particulier de tableau utilisé dans le Tidyverse. Il présente notamment l’avantage d’afficher les types de variables sous les noms de colonnes.\r\n\r\nRenommer des variables avec rename()\r\nCette fonction s’utilise de la façon suivante : rename(objet, nouveau_nom = ancien_nom).\r\n\r\n\r\n# Supprimer les majuscules dans les noms de colonnes\r\ncroissance <- rename(croissance,\r\n                      zone = Zone,\r\n                      indiv = Indiv)\r\n\r\n\r\n\r\n Avant d’aller plus loin, nous allons voir une fonctionnalité extrêmement pratique : le “pipe”. Un pipe permet d’enchaîner les opérations, et présente plusieurs avantages, notamment de rendre le code plus clair et lisible et de rendre possible l’auto-complétion (à l’aide de la touche Tab).\r\nLe pipe fait partie du package magrittr, inclus dans le Tidyverse.\r\nUn pipe se place à la fin d’un ligne sous la forme %>% :\r\n\r\nRaccourci clavier : Ctrl + Shift + M\r\n\r\n\r\ncroissance <- croissance %>% \r\n  rename(zone = Zone,\r\n         indiv = Indiv)\r\n\r\n\r\n\r\n\r\nSélectionner des colonnes avec select()\r\nCette fonction permet de sélectionner des colonnes, en précisant lesquelles conserver ou supprimer :\r\n\r\n\r\n# Conserver des colonnes\r\n\r\ncroissance_selection <- croissance %>% \r\n  select(indiv, `2007`:`2012`)\r\n\r\n# Supprimer une colonne\r\n\r\ncroissance_selection <- croissance %>% \r\n  select(-zone)\r\n\r\n\r\n\r\n\r\nLa fonction select() permet également de renommer des colonnes et d’en modifier l’ordre :\r\n\r\n\r\n# Renommer et modifier l'ordre de colonnes\r\n\r\ncroissance_selection <- croissance %>% \r\n  select(zone = Zone, indiv = Indiv, `2007`:`2012`)\r\n\r\n\r\n\r\n\r\nL’opérateur : permet de construire une séquence : dans le cas présent il permet de sélectionner toutes les colonnes entre 2007 et 2012.\r\nSi vous souhaitez renommer ou déplacer seulement quelques colonnes, la fonction everything() vous permet de sélectionner toutes les colonnes restantes :\r\n\r\n\r\ncroissance_selection <- croissance %>% \r\n  select(zone = Zone, indiv = Indiv, everything())\r\n\r\n\r\n\r\n\r\nFiltrer des données avec filter()\r\nCette fonction permet de sélectionner des lignes à l’aide d’opérateurs logiques :\r\nOpérateur\r\nExpression logique\r\n==\r\nstrictement égal à\r\n<=\r\ninférieur ou égal à\r\n<\r\ninférieur à\r\n>=\r\nsupérieur ou égal à\r\n>\r\nsupérieur à\r\n!=\r\ndifférent de\r\n%in%\r\nappartient à\r\n&\r\net\r\n|\r\nou\r\n!\r\npas\r\nVoyons comment utiliser ces opérateurs logiques :\r\n\r\n\r\n# individu n°603\r\n\r\ncroissance %>% filter(indiv == 603)\r\n\r\n# zones 2, 3 et 4\r\n\r\ncroissance %>% filter(zone <= 4)\r\ncroissance %>% filter(zone %in% c(2, 3, 4))\r\ncroissance %>% filter(zone %in% 2:4)\r\ncroissance %>% filter(!zone >= 5)\r\n\r\n# zones 2 et 7\r\n\r\ncroissance %>% filter(zone == 2 | zone == 7)\r\ncroissance %>% filter(zone %in% c(2, 7))\r\n\r\n# zone 2 + individus entre 300 et 400\r\n\r\ncroissance %>% filter(zone == 2 & indiv %in% 300:400)\r\ncroissance %>% filter(zone == 2 & between(indiv, 300, 400))\r\n\r\n\r\n\r\n\r\nIl existe différentes façons de construire une séquence :\r\n\r\n\r\nseq(from = 300, to = 400, by = 10)  # de 300 a 400 avec un increment de 10\r\nrep(x = c(300, 350), times = 2)  # 2 repetitions du vecteur \"300, 350\"\r\nrep(x = c(300, 350), each = 2)  # chaque element du vecteur \"300, 350\" est repete 2 fois\r\nrep(seq(from = 300, to = 400, by = 10), times = 4)  # combinaison des deux\r\n\r\n\r\n\r\n\r\nTrier des données avec arrange()\r\nLa fonction arrange() permet de trier des valeurs par ordre croissant ou décroissant :\r\n\r\n\r\n# Trier par ordre croissant sur l'annee 2007\r\n\r\ncroissance %>% arrange(`2007`)\r\n\r\n# Trier par ordre decroissant sur l'annee 2008\r\n\r\ncroissance %>% arrange(desc(`2008`))\r\n\r\n\r\n\r\n\r\nCréer de nouvelles colonnes avec mutate()\r\nLa fonction mutate() permet de créer un nouvelle colonne :\r\n\r\n\r\n# Calculer la croissance totale pour chaque individu entre 2007 et 2012\r\n\r\ncroissance_totale <- croissance %>% \r\n  mutate(croissance.totale = `2007` + `2008` + `2009` + `2010` + `2011` + `2012`)\r\n\r\n\r\n\r\n\r\nDéfinir des groupes avec group_by()\r\nCette fonction permet de créer une structure interne à vos données, par exemple des individus regroupés par zone. Les fonctions exécutées après l’appel à la fonction group_by() tiendront compte de cette structure interne. L’utilisation de la fonction group_by() associée à d’autres fonctions est très utile pour calculer des statistiques pour différents sites, traitements, espèces, …\r\n\r\n\r\n# Grouper les individus par zone\r\n\r\ncroissance_groupes <- croissance %>% \r\n  group_by(zone)\r\n\r\n\r\n\r\n\r\nComparez les deux objets croissance et croissance_groupes. La seule différence visible est la mention Groups quand vous affichez l’objet possédant une structure interne. Pour l’instant, les groupes créés par group_by() sont sous-jacents, et leur intérêt sera évident en appliquant d’autres fonctions à ces groupes.\r\n\r\nAgréger des lignes et calculer des statistiques avec summarise()\r\nCette fonction permet d’agréger des lignes en appliquant une fonction sur une ou plusieurs colonnes :\r\n\r\n\r\n# Croissance totale pour l'ensemble des individus pour l'annee 2007\r\n\r\nsynthese1 <- croissance %>% \r\n  summarise(croissance.totale.2007 = sum(`2007`))\r\n\r\n# Croissance totale pour l'ensemble des individus groupes par zone pour l'annee 2007\r\n\r\nsynthese2 <- croissance_groupes %>% \r\n  summarise(croissance.totale.2007 = sum(`2007`))\r\n\r\n\r\n\r\n\r\nLe premier objet, synthese1, correspond à la somme de toutes les valeurs de croissance pour tous les individus en 2007. Le second objet, synthese2, correspond à la somme des valeurs de croissance pour les individus regroupés par zone en 2007.\r\n\r\nLes données étant agrégées, le tableau de sortie sera plus court que les données d’origine.\r\nVous pouvez de cette façon calculer plusieurs paramètres :\r\n\r\n\r\nsynthese3 <- croissance_groupes %>% \r\n  summarise(croissance.totale.2007 = sum(`2007`),\r\n            croissance.moyenne.2007 = mean(`2007`),\r\n            croissance.ecart.type.2007 = sd(`2007`)) \r\n\r\n\r\n\r\n\r\nJoindre des données avec ..._join()\r\nIl peut arriver que des données concernant un même projet se trouvent dans plusieurs fichiers (par exemple un fichier avec des mesures sur différents sites, et un autre fichier avec des données climatiques pour ces différents sites).\r\n\r\nLes différentes fonctions ..._join() permettent de joindre plusieux jeux de données selon ce qu’on souhaite faire des données qui ne sont pas partagées. Les lignes d’un tableau seront associées à l’autre tableau selon les valeurs d’une ou de plusieurs colonnes partagées (les clés).\r\n\r\n\r\n\r\nFigure tirée de R for Data Science\r\n\r\nLe fichier traitements.csv contient des informations sur des traitements appliqués aux plantes : températe (T), fertilisation (F), température + fertilisation (TF), ou contrôle (C).\r\n\r\n\r\n# Importer le jeu de données (attention : utilisation de read_csv2)\r\n\r\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\r\n\r\n\r\n\r\n\r\nNous allons utiliser la fonction left_join() pour garder toutes les données présentes dans croissance et y associer les données présentes dans traitements :\r\n\r\n\r\n# Joindre deux jeux de données\r\n\r\nexpe <- croissance %>% \r\n  left_join(traitements,\r\n            by = c(\"zone\" = \"Zone\",\r\n                   \"indiv\" = \"Indiv\"))\r\n\r\n\r\n\r\n\r\nSi les noms des deux premières colonnes avaient été strictement identiques dans les deux tableaux, nous aurions pu nous passer de l’argument by().\r\n\r\nMettre en forme des données à l’aide de tidyr\r\nLes données que nous avons manipulées jusqu’à présent ne sont pas dans un format idéal (rappelez-vous la longueur du code pour calculer la croissance totale pour chaque individu).\r\nLes valeurs mesurées sont réparties dans différentes colonnes, une par année.\r\nNous pourrions mettre en forme ces donnes afin d’avoir une colonne “annee” et une colonne “croissance”.\r\nC’est ce qu’on appelle des tidy data, concept qui repose sur trois critères :\r\n1. Chaque variable est située dans sa propre colonne2. Chaque observation est située sur sa propre ligne3. Chaque valeur est située dans sa propre cellule\r\n\r\n\r\n\r\nFigure tirée de R for Data Science\r\n\r\nConsidérons les deux premières lignes de notre tableau croissance, voici à quoi ressemblerait un format tidy :\r\n\r\n\r\n\r\n\r\nCe format facilite les analyses en permettant des comparaisons entre groupes, traitements, espèces, années, …\r\nLe package tidyr permet de jongler entre ces deux formats grâce aux fonctions pivot_...().\r\n\r\n\r\n\r\n\r\nFormat long avec pivot_longer()\r\nLa fonction pivot_longer() permet de passer d’un format large à un format long. La syntaxe est un peu plus complexe que les fonctions que nous avons vues jusqu’à présent, car il nous préciser quelles colonnes vont être regroupées :\r\n\r\n\r\n\r\n\r\n\r\n# Format large -> format long\r\n\r\ncroissance_long <- croissance %>% \r\n  pivot_longer(cols = `2007`:`2012`,\r\n               names_to = \"annee\",\r\n               values_to = \"croissance\")\r\n\r\n\r\n\r\n\r\nFormat large avec pivot_wider()\r\nCette fonction permet d’effectuer l’opération inverse :\r\n\r\n\r\n\r\n\r\n\r\n# Format long -> format large\r\n\r\ncroissance_large <- croissance_long %>% \r\n  pivot_wider(id_cols = zone:indiv,\r\n              names_from = annee,\r\n              values_from = croissance)\r\n\r\n\r\n\r\n\r\nDans les arguments names_from et values_from nous n’utilisons pas de guillemets car ces colonnes existent, contraitement aux arguments names_to et values_to de la fonction pivot_longer() qui permettent de créer des colonnes inexistantes.\r\n\r\nRésumé\r\nNous avons vu les principales fonctions des packages dplyr et tidyr une par une. Nous allons maintenant enchaîner les différentes opérations depuis le début à l’aide d’un pipe et visualiser l’effet des différents traitements sur la croissance des tiges d’Empetrum :\r\n\r\n\r\n# Importer les deux fichiers\r\n\r\ncroissance <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/croissance.csv\")\r\ntraitements <- read_csv2(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv\")\r\n\r\n# Mettre en forme et joindre les deux fichiers\r\n\r\nexpe <- croissance %>% \r\n  pivot_longer(cols = `2007`:`2012`,\r\n               names_to = \"annee\",\r\n               values_to = \"croissance\") %>% \r\n  left_join(traitements) %>% \r\n  rename(zone = Zone,\r\n         indiv = Indiv,\r\n         traitement = Traitement) %>% \r\n  mutate(zone = as.factor(zone),\r\n         indiv = as.factor(indiv),\r\n         annee = as.numeric(annee),\r\n         traitement = as.factor(traitement))\r\n\r\n# Boxplot de l'effet des traitements sur la croissance\r\n\r\nboxplot(croissance ~ traitement, \r\n        data = expe,\r\n        main = \"Effet de la température (T) et de la fertilisation (F) sur la croissance d'Empetrum\",\r\n        xlab = \"Traitement\",\r\n        ylab = \"Croissance des tiges (cm)\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nBilan du tutoriel :\r\nVous savez utiliser les fonctions de dplyr pour manipuler vos données\r\nVous savez mettre en forme des données qui respectent les critères des tidy data avec tidyr\r\n\r\nDéfi\r\nPour ce défi, nous allons essayer de répondre à la question suivante : quelle est l’effet de différentes épices sur la taille des flammes de trois espèces de dragons ? \r\n\r\nCommençons par importer les données :\r\n\r\n\r\ndragons <- read.csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\r\n\r\n\r\n\r\n\r\nVoici les objectifs de ce défi :\r\nmettre en forme les données (format tidy)\r\ncréer un boxplot pour chaque espèce montrant l’effet des épices sur la taille des flammes\r\n\r\nMalheureusement, vous apprenez que votre assistant a été peu scrupuleux lors de la collecte des données, et il vous faut corriger les erreurs suivantes :\r\nLa quatrième épice n’était pas du paprika, mais du curcuma\r\nLors des mesures avec le tabasco, l’appareil était mal calibré, mais seulement pour les Magyar à pointes : la taille des flammes a été sur-estimée de 30 cm\r\nLes tailles sont données en centimètres, alors qu’elles devraient être en mètres.\r\n\r\nA votre tour de jouer!\r\n\r\nSi vous êtes coincé, vous pouvez cliquer ci-dessous pour afficher quelques astuces :\r\n\r\n\r\nShow code\r\n\r\n# 1. Pour renommer la colonne \"paprika\", utilisez la fonction rename()\r\n\r\n# 2. Il existe plusieurs facons de corriger des valeurs :\r\n\r\nvaleurs_corrigees <- dragons$tabasco[dragons$espece == \"magyar_a_pointe\"] - 30\r\ndragons$tabasco[dragons$espece == \"magyar_a_pointe\"] <- valeurs_corrigees\r\n\r\ndragons <- dragons %>% \r\n  mutate(tabasco = ifelse(espece == \"magyar_a_pointe\", tabasco - 30, tabasco))\r\n\r\ndragons <- dragons %>% \r\n  mutate(tabasco = case_when(espece == \"magyar_a_pointe\" ~ tabasco - 30,\r\n                             TRUE ~ tabasco))\r\n\r\n# 3. La fonction mutate() vous permettra de convertir les centimètres en mètres\r\n\r\n\r\n\r\n\r\nCliquez ci-dessous pour voir la solution\r\n\r\n\r\nShow code\r\n\r\n# Importer les donnees\r\n\r\ndragons <- read_csv(\"https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv\")\r\n\r\n# Nettoyer et corriger les donnees\r\n\r\ndragons_tidy <- dragons %>% \r\n  rename(curcuma = paprika) %>% \r\n  pivot_longer(cols = tabasco:curcuma,\r\n               names_to = \"epice\",\r\n               values_to = \"flamme_cm\") %>% \r\n  mutate(flamme_cm = case_when(espece == \"magyar_a_pointes\" & epice == \"tabasco\" ~ flamme_cm - 30,\r\n                               TRUE ~ flamme_cm)) %>% \r\n  mutate(flamme_m = flamme_cm / 100)\r\n\r\nmagyar_a_pointes <- dragons_tidy %>% filter(espece == \"magyar_a_pointes\")\r\nsuedois_a_museau_court <- dragons_tidy %>% filter(espece == \"suedois_a_museau_court\")\r\nvert_gallois <- dragons_tidy %>% filter(espece == \"vert_gallois\")\r\n\r\n# Boxplots\r\n\r\npar(mfrow = c(1, 3))\r\n\r\nboxplot(flamme_m ~ epice,\r\n        data = magyar_a_pointes,\r\n        xlab = \"Epice\",\r\n        ylab = \"Longueur flamme (m)\",\r\n        main = \"Magyar à pointes\")\r\n\r\nboxplot(flamme_m ~ epice,\r\n        data = suedois_a_museau_court,\r\n        xlab = \"Epice\",\r\n        ylab = \"Longueur flamme (m)\",\r\n        main = \"Suédois à museau court\")\r\n\r\nboxplot(flamme_m ~ epice,\r\n        data = vert_gallois,\r\n        xlab = \"Epice\",\r\n        ylab = \"Longueur flamme (m)\",\r\n        main = \"Vert gallois\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/manipuler-donnees-tidyverse/img/data_cowboy.png",
    "last_modified": "2022-05-30T15:19:46+02:00",
    "input_file": {}
  },
  {
    "path": "posts/premiers-pas-avec-r/",
    "title": "Premiers pas avec R",
    "description": "Débuter avec R et RStudio.",
    "author": [
      {
        "name": "Gergana Daskalova",
        "url": "https://ourcodingclub.github.io/tutorials/intro-to-r/"
      },
      {
        "name": "Jonathan Kitt (adaptation)",
        "url": {}
      }
    ],
    "date": "2022-05-02",
    "categories": [
      "R",
      "RStudio",
      "Introduction"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nTélécharger R et RStudio\r\nImporter et vérifier les données\r\nCompter le nombre d’espèces menacées\r\nCréer un vecteur et le représenter\r\nCréer un dataframe et le représenter\r\nDéfi\r\nGlossaire\r\n\r\n\r\n\r\n\r\nCe tutoriel est adapté de Getting started with R and RStudio du site Our Coding Club.\r\n\r\n\r\n\r\nDessin de Allison Horst\r\nIntroduction\r\n\r\nLes objectifs de ce tutoriel sont les suivants :\r\nComprendre ce qu’est R (et RStudio)\r\nPrendre la bonne habitude de travailler avec des scripts\r\nApprendre à importer des données dans R\r\nApprendre à manipuler des objets (vecteurs et data frames)\r\nCréer un graphique basique\r\nVoici les étapes que nous allons suivre pour y parvenir :\r\nTélécharger R et RStudio\r\nImporter et vérifier les données\r\nCompter le nombre d’espèces menacées\r\nCréer un vecteur et le représenter\r\nCréer un data frame et le représenter\r\nDéfi\r\nGlossaire\r\nQu’est-ce que R?\r\nR est un langage de programmation statistique qui a rapidement gagné en popularité dans de nombreux domaines scientifiques. Il a été développé par Ross Ihaka et Robert Gentleman comme implémentation libre du langage de programmation S.\r\n\r\nR désigne également le logiciel qui utilise ce langage pour des calculs statistiques (et tout un tas d’autres applications !). Il dispose d’une communauté en ligne très active ainsi que d’extensions pour presque tous les domaines et applications possibles et imaginables.\r\n\r\nContrairement à d’autres logiciels de statistiques comme Minitab ou SPSS, R peut être exécuté entièrement en ligne de commande et ne nécessite pas d’interface graphique, ce qui lui confère une grande flexibilité.\r\n\r\nVoici quelques avantages de R :\r\nC’est un outil libre et open source (tout le monde peut utiliser le code et voir comment il fonctionne)\r\nC’est un langage de programmation plutôt qu’une interface graphique, ce qui permet à l’utilisateur de sauvegarder facilement des scripts sous forme de texte pour les ré-utiliser ou les partager\r\nBeaucoup de personnes l’utilisent dans beaucoup de domaines différents - il est rare d’être confronté à un problème qui n’a jamais été résolu !\r\n\r\nTélécharger R et RStudio\r\nLa plupart des utilisateurs interagissent avec R à l’aide d’une interface graphique, dont la plus connue est RStudio. RStudio permet d’avoir accès dans une seule fenêtre à vos scripts, à vos données, à vos graphiques, à vos résultats, ainsi qu’à de l’aide.\r\n\r\nTéléchargez R sur le site du CRAN (The Comprehensive R Archive Network)\r\nTéléchargez RStudio (“free open source desktop version”)\r\nSur Mac, vous aurez également besoin de XQuartz\r\n\r\nOuvrez RStudio, puis cliquez sur “File / New File / R script”\r\n\r\n\r\n\r\nVous verrez une fenêtre comme celle ci-dessus, avec quatre panneaux :\r\n1) La console : vous pouvez y taper du code et l’exécuter avec Entrée.\r\n\r\nEssayez de taper et d’exécuter 2+2\r\n2) Le script : vous pouvez - et c’est préférable - y taper du code. Pour l’exécuter, placez-vous à la fin de la ligne et utilisez la combinaison de touches Ctrl + R (Windows) ou Cmd + Entrée (Mac).\r\n\r\nSur les ordinateurs avec une version récente de Windows, Ctrl + Entrée\r\n3) L’environnement : aperçu de votre espace de travail (données importées, objets créés, fonctions définies, …).\r\n4) Fichiers / Graphiques / Packages / Aide : permet de naviguer dans vos dossiers, de visualiser vos graphiques, de voir quels packages sont installés et chargés, et d’obtenir de l’aide.\r\nA propos des scripts :  gardez bien à l’esprit que le code tapé directement dans la console ne sera pas sauvegardé par R : il disparaît une fois exécuté (vous pouvez toutefois accéder aux dernières commandes à l’aide de la touche Flèche du haut de votre clavier). L’utilisation d’un script pour taper votre code vous permet d’en garder une trace. C’est un peu comme quand vous rédigez un document dans Word : vous pouvez sauvegarder votre progression pour reprendre là où vous en étiez, ou faire des modifications. Lorsque vous tapez du code dans un script, pensez à le sauvegarder régulièrement (Ctrl + S).\r\nIl est fortement recommandé d’ajouter à votre code des commentaires décrivant les étapes. Pour cela, insérez un hashtag (#) devant une ligne de votre script (ou Ctrl + Shift + C). Toutes les lignes qui commencent par un # seront considérées par R comme du texte et non du code, et ne seront pas exécutées. Ces commentaires apporteront des informations précieuses pour toute personne qui lira votre script (y compris vous-même quand vous reviendrez dessus dans un certain temps !). Comme tout document écrit, les scripts sont plus facilement lisibles quand ils sont bien structurés et clairs.\r\nA propos de l’espace de travail :  votre espace de travail contient tout ce que vous utilisez lors d’une session R. En quittant R, vous aurez le choix de sauvegarder ou non cet espace de travail. Il est préférable de ne pas le faire et de démarrer chaque session avec en espace de travail vide. \r\nTéléchargez les données\r\nLa meilleure façon d’apprendre un nouveau langage est de le pratiquer. Nous allons analyser une liste d’espèces d’oiseaux menacées en Auvergne (données de 2015 obtenues sur le site de la DREAL). Ces données se trouvent dans un fichier appelé oiseaux.csv.\r\n1) Créez un nouveau dossier sur votre ordinateur : vous allez y télécharger les données, et vous pourrez y sauvegarder votre script et vos graphiques. Choisissez un nom explicite, par exemple codons_01_intro_r\r\n\r\nEvitez les espaces vides dans vos noms de dossiers !\r\n2) Cliquez sur ce lien pour télécharger le fichier oiseaux.csv\r\n3) Cliquez sur “Code” puis “Download ZIP” (voir ci-dessous)\r\n\r\n\r\n\r\n4) Choisissez comme emplacement de sauvegarde le dossier que vous venez de créer\r\n5) Dézippez le dossier\r\nCommencez à écrire votre script\r\nPour l’instant, vous pouvez noter la date et l’objectif du tutoriel - compter le nombre d’espèces d’oiseaux menacées d’extinction en Auvergne. Vous pouvez copier l’exemple ci-dessous pour le coller et l’éditer dans votre propre script :\r\n\r\n\r\n# Ateliers codon(s)!\r\n# 01 - Premiers pas avec R\r\n# Lundi 09/05/2022\r\n\r\n\r\n\r\nLes lignes suivantes dans votre script servent généralement à charger les packages dont vous aurez besoin pour votre analyse. Un package contient des commandes qui peuvent être chargées dans R pour apporter des fonctionnalités supplémentaires (il existe par exemple des packages pour formater des données ou pour créer des cartes).\r\nUn package doit tout d’abord être téléchargé et installé sur votre ordinateur à l’aide de la commande install.packages(\"nom-du-package\") avant d’être chargé pour être utilisé à l’aide de la commande library(nom-du-package). Un package n’a besoin d’être installé qu’une seule fois, vous pouvez donc le faire directement dans la console plutôt que de sauvegarder la ligne de code dans votre script et d’ainsi le ré-installer à chaque fois que vous exécutez votre script. Nous allons utiliser le package dplyr qui fournit des fonctionnalités supplémentaires pour la manipulation et le formatage de données.\r\n\r\nNotez bien la présence de guillemets autour du nom du package dans l’appel à la fonction install.packages(), et leur absence dans l’appel à la fonction library()\r\n\r\n\r\ninstall.packages(\"dplyr\")\r\nlibrary(dplyr)\r\n\r\n\r\n\r\nNous allons maintenant définir notre répertoire de travail - le dossier dans lequel R cherchera les données à importer et sauvegardera les graphiques. C’est dans notre cas le dossier dans lequel nous avons téléchargé les données.\r\nQuand vous aurez à travailler sur des projets plus importants, vous pourrez tout à fait créer un dossier racine (par ex. “nom_du_projet/”), le définir comme répertoire de travail, et créer des sous-dossiers pour organiser les fichiers (par ex. “nom_du_projet/donnees_brutes/”, “nom_du_projet/figures/”, …).\r\nPour afficher le réperoire de travail, utilisez la commande getwd() (pour get working directory). La commande setwd(\"nom-du-repertoire-de-travail\") (set working directory) permet de définir un nouveau répertoire de travail.\r\n\r\nFaites attention au sens des slashes dans vos chemins de dossiers !\r\n\r\n\r\nsetwd(\"C:/User/Codons-01-PremiersPasAvecR\")\r\n# Remplacez le chemin ci-dessus par le votre\r\n\r\n\r\n\r\n\r\nL’auto-complétion est votre alliée ! Tapez quelques lettres puis sur la touche Tab et R complètera pour vous.\r\nImporter et vérifier les données\r\nPour importer les données dans RStudio, deux options s’offrent à vous :\r\nCliquer sur le bouton Import Dataset\r\n\r\n\r\n\r\nIndiquez quel fichier vous souhaitez importer, et RStudio vous proposera un aperçu de vos données. Assurez-vous qu’à côté de Heading vous avez sélectionné Yes (ceci indique à R qu’il doit considérer la première ligne de vos données comme des noms de colonnes). Cliquez enfin sur Import.\r\n\r\n\r\n\r\nDans la console vous verrez le code utilisé pour importer vos données, y compris le chemin vers votre fichier - il est utile de copier cette ligne de code et de la coller dans votre script, pour que vous sachiez d’où vient votre jeu de données.\r\nVous remarquerez que le chemin vers votre fichier débute par C:/. Il s’agit du chemin absolu vers le fichier à importer, qui ne tient pas compte du fait que vous avez défini un répertoire de travail. Vous pouvez également utiliser le chemin relatif qui indique l’emplacement du fichier à partir de votre répertoire de travail (voir ci-dessous)\r\nUtiliser la commande read.csv() : R fonctionne mieux avec des fichiers .csv (valeurs séparées par des virgules). Si vous travaillez dans Excel, cliquez sur Enregistrer sous et choisissez csv comme extension de fichier.\r\n\r\nDans Excel, évitez les espaces dans vos noms de colonnes (ex : nom_latin plutôt que nom latin)\r\nCertains ordinateurs utilisent le point-virgule ; comme séparateur dans les fichiers .csv. Vous pouvez dans ce cas utiliser la fonction read.csv2(), ou préciser dans la fonction read.csv() l’argument sep = \";\".\r\n\r\n\r\noiseaux <- read.csv(\"Codons-01-PremiersPasAvecR-main/oiseaux.csv\")\r\n# modifiez le chemin vers le fichier si nécessaire\r\n\r\n\r\n\r\nA propos des objets : R est langage orienté objet - cela signifie que tout ce que vous importez et créez est stocké dans des objets que vous allez nommer. Ici, nous avons assigné le fichier oiseaux.csv à l’objet oiseaux à l’aide de la flèche <-. Nous aurions tout à fait pu l’appeler mesdonnees ou oiseaux_liste_rouge_auvergne, mais il est préférable de choisir un nom unique, informatif et court. Dans le panneau Environment de RStudio vous pouvez voir les noms de tous les objets actuellement chargés dans R. Assurez-vous que vous voyez bien l’objet oiseaux.\r\nQuand vous importez vos données dans R, il est très probable qu’elles deviennent un objet qu’on appelle un data frame : un tableau contenant des lignes (observations) et des colonnes (variables).\r\nUne des premières choses à faire est de vous assurer que vos données ont été importées sans erreur. Il est recommandé de toujours exécuter ce code dans la console et de vérifier le résultat - voyez-vous des erreurs, est-ce que les nombres/noms ont du sens ? Si vous passiez directement à l’analyse, vous risqueriez de vous rendre compte plus tard que R n’a pas importé vos données correctement et vous devriez recommencer, ou pire, vous pourriez analyser de mauvaises données sans vous en rendre compte. Pour visualiser davantage que les quelques premières lignes, vous pouvez également cliquer sur l’objet dans le panneau Environment, ce qui affichera un tableau dans un nouvel onglet à côté de votre script. Des fichiers peuvent être trop larges pour êtres affichés entirement, gardez donc à l’esprit qu’il peut y avoir des lignes ou des colonnes manquantes.\r\n\r\n\r\nhead(oiseaux)  # affiche les premières lignes\r\ntail(oiseaux)  # affiche les dernières lignes\r\nstr(oiseaux)  # affiche le type de variables\r\n\r\n\r\n\r\nLa commande str(nom.objet) affiche la structure de vos données. Très souvent, les analyses ne se déroulent pas comme prévu car R s’est trompé de type de variable. Imaginez que vos données comportent quatre groupes d’étude appelés “1, 2, 3, 4”. Vous savez pertinnement qu’il s’agit d’une variable catégorique (un facteur), mais R peut considérer qu’il s’agit d’une variable numérique.\r\n\r\nPensez toujours à vérifier la structure de vos données !\r\nLa fonction str(oiseaux) nous indique que la variable categorie est une chaîne de caractères (chr). Nous préférerions que R considère cette variable comme étant catégorique - un facteur. Nous allons le préciser en accédant à la colonne concernée à l’aide du signe dollar $ :\r\n\r\n\r\nhead(oiseaux$categorie)  # premiers éléments de la variable\r\nclass(oiseaux$categorie)  # type de variable\r\noiseaux$categorie <- as.factor(oiseaux$categorie)\r\n\r\n\r\n\r\nLa dernière ligne du code ci-dessus permet de transformer la variable categorie en un facteur. La fonction as.factor(oiseaux$categorie) toute seule serait exécutée, mais ne modifierait pas les données stockées dans l’objet oiseaux. Il faut pour cela ré-assigner cette variable transformée en facteur à la variable d’origine. Pour vous assurer que l’opération a bien fonctionné, vous pouvez exécuter à nouveau la fonction class(oiseaux$categorie).\r\nLes fonctions suivantes permettent d’explorer autrement vos données :\r\n\r\n\r\ndim(oiseaux)  # dimensions de l'objet\r\nsummary(oiseaux)  # synthèse de l'objet\r\nsummary(oiseaux$categorie)  # synthèse de la variable\r\n\r\n\r\n\r\nCompter le nombre d’espèces menacées\r\nNotre objet oiseaux dresse une liste des espèces d’oiseaux menacées d’extinction en Auvergne, avec différents niveaux de préoccupation.\r\nNous allons compter le nombre d’espèces pour chaque niveau de préoccupation et créer une visualisation de ce comptage.\r\nCommençons par séparer oiseaux en plusieurs objets, un pour chaque niveau de menace, à l’aide de la fonction filter() du package dplyr.\r\n\r\n\r\nen_danger_critique <- filter(oiseaux, categorie == \"En danger critique\")\r\n# Le 1er argument de la fonction est le data frame, \r\n# Le 2e argument est la condition à appliquer au filtre\r\n\r\n\r\n\r\n\r\nL’opérateur == permet de sélectionner les valeurs “strictement égales à”\r\nR est sensible à la casse : filter(oiseaux, categorie == \"en danger critique\") ne fonctionnera pas !\r\nProcédons de la même façon pour chaque catégorie. Si vous avez un doute sur le nom ou l’orthographe d’une des catégories, pensez à la fonction summary(oiseaux$categorie).\r\nUne fois que vous avez créé tous les objets, vous allez pouvoir compter le nombre d’espèces pour chaque catégorie. Nous allons pour cela imbriquer deux fonctions : unique() (pour identifier chaque espèce) et length() (pour les compter).\r\n\r\nVous pouvez essayer ces deux fonctions séparément dans la console\r\n\r\n\r\na <- length(unique(en_danger_critique$nom_francais))\r\n# choisissez des noms pratiques pour vos objets\r\n# \"a\" n'est peut-être pas le plus explicite ...\r\n\r\n\r\n\r\nProcédez de la même façon pour toutes les catégories. Cette manière de procéder peut vous sembler rébarbative … Nous verrons dans un prochain tutoriel comment procéder de manière plus efficace !\r\nTapez dans la console le nom d’un des objets que vous venez de créer. Que vous retourne-t-elle ?\r\nCréer un vecteur et le représenter\r\nNous allons maintenant combiner tous ces objets dans un vecteur - un objet à une dimension (à la différence d’un data frame qui en possède deux).\r\nNous utilisons pour cela la fonction c() (pour concaténer), ainsi que la fonction names() pour ajouter des étiquettes aux valeurs.\r\n\r\n\r\ncomptage_especes <- c(a,b, c, d, e)\r\nnames(comptage_especes) <- c(\"En danger critique\",\r\n                             \"En danger\",\r\n                             \"Vulnerable\",\r\n                             \"Quasi-menacee\",\r\n                             \"Preoccupation mineure\")\r\n\r\n\r\n\r\n\r\nAttention à garder le même ordre !\r\nNotes :\r\n- Les espaces avant et après la flèche <- et après la virgule , facilitent la lecture du code\r\n- Faites attention à vérifier que les valeurs du vecteur correspondent bien aux étiquettes - vous ne voudriez pas inverser les espèces “En danger critique” avec les espèces “Quasi-menacées”! L’utilisation d’un script permet de revenir sur le code et de vérifier qu’on ne s’est pas trompé. Une bonne pratique serait de nommer les objets de façon plus explicite, comme nb_en_danger_critique, nb_en_danger, …\r\n- Si vous cliquez à l’aide de la souris après une parenthèse, RStudio surlignera la parenthèse lui correspondant. Les parenthèses manquantes, en particulier quand vous utilisez des fonctions imbriquées comme vous l’avez fait avec length(unique()) sont une des sources de frustration et d’erreur les plus courantes quand vous commencez à coder !\r\nNous pouvons maintenant visualiser le nombre d’espèces par catégorie à l’aide de la fonction barplot(). Les graphiques s’affichent dans le panneau inférieur droit de RStudio.\r\n\r\n\r\nbarplot(comptage_especes)\r\n\r\n\r\n\r\nEt voilà votre premier graphique avec R ! Mais il y a des choses à modifier : il manque des titres aux axes, toutes les étiquettes ne sont pas visibles, et la valeur pour les espèces dans la catégorie “Préoccupation mineure” (n = 68) dépasse la plus grande valeur affichée sur l’axe Y.\r\nPour savoir comment apporter ces modifications à votre graphique, utilisez la fonction help(barplot) ou ?barplot pour afficher l’aide de la fonction. Survolez le document qui s’affiche et essayez de trouver des solutions.\r\n\r\n\r\nhelp(barplot)  # aide de la fonction barplot\r\nhelp(par)  # aide pour les graphiques\r\n\r\n\r\n\r\nNous aimerions également sauvegarder notre graphique. Là encore, vous avez deux options : - Cliquer sur Export dans le panneau des graphiques : choisissez où sauvegarder le graphique (par défaut dans votre répertoire de travail) et modifiez le nom du fichier pour qu’il soit plus explicite que Rplot01.png. Vous pouvez aussi ajuster les dimensions de la figure.\r\n\r\n\r\n\r\nUtiliser les fonctions png() et dev.off() qui servent respectivement à ouvrir et fermer l’outil graphique :\r\n\r\n\r\npng(\"barplot.png\",\r\n    width = 1600, height = 600)\r\n\r\nbarplot(comptage_especes,\r\n        xlab = \"Niveau de menace\", ylab = \"Nombre d'espèces\",\r\n        ylim = c(0, 70),\r\n        cex.names = 1.5, cex.axis = 1.5, cex.lab = 1.5)\r\n\r\ndev.off()\r\n\r\n\r\n\r\n\r\nL’argument cex permet d’augmenter (> 1) ou de diminuer (< 1) la taille du texte\r\n\r\n\r\n\r\nCréer un dataframe et le représenter\r\nNous avons travaillé jusqu’ici avec des vecteurs, un type d’objet bien adapté quand on manipule une seule série de valeurs à la fois. Dans la pratique, nous manipulons souvent plusieurs variables et plusieurs types de données en même temps - par exemple des valeurs continues et des valeurs catégoriques. Les data frames sont alors mieux adaptés : il s’agit de tableaux de valeurs ayant une structure en deux dimensions, des lignes et des colonnes, chaque colonne pouvant contenir un type différent de données.\r\nNous pourrions par exemple avoir un tableau de données dont une colonne appelée “Envergure” contient des mesures d’envergures chez différentes espèces d’oiseaux, et une deuxième colonne appelée “Espèce” contient les noms des espèces dont on a mesuré l’envergure.\r\nLa matrice est un autre format possible de données : elle peut également contenir plusieurs lignes, mais toutes les variables d’une matrice doivent être du même type et contenir le même nombre d’éléments.\r\nConseil de bonne pratique : conservez toujours une copie de vos données brutes ! Votre script R vous permet de manipuler et modifier ces données sans toucher aux données brutes. Si vous utilisez des logiciels de retouche photo, c’est un peu la même chose que d’ajouter des couches apportant des modifications à votre cliché sans modifier la photo d’origine. Ceci dit, si vos données brutes nécessitent un long morceau de code pour être analysables, vous pouvez sauvegarder une version nettoyée de vos données brutes pour ne pas avoir à refaire toutes les étapes de nettoyage des données.\r\nNous allons utiliser deux nouvelles fonctions : data.frame() pour créer notre data frame et write.csv() pour le sauvegarder. Nous allons créer les objets “categories” et “comptage”, transformer l’objet “categories” en facteur, puis rassembler ces deux objets dans un data frame.\r\n\r\n\r\n# Creer un objet \"categories\"\r\ncategories <- c(\"En danger critique\",\r\n                \"En danger\",\r\n                \"Vulnerable\",\r\n                \"Quasi-menacee\",\r\n                \"Preoccupation mineure\")\r\n\r\n# Transformer cet objet en facteur\r\ncategories_f <- factor(categories)\r\n\r\n# Creer un objet \"comptage\"\r\ncomptage <- c(a, b, c, d, e)\r\n\r\n# Creer un data frame avec ces deux vecteurs\r\nespeces_menacees <- data.frame(categories_f, comptage)\r\n\r\n# Sauvegarder le data frame\r\nwrite.csv(especes_menacees, file = \"especes_menacees.csv\")\r\n\r\n\r\n\r\nPour créer un barplot à partir de ce data frame, vous devrez modifier le code utilisé précédemment - il faut en effet préciser quelle variable du data frame vous souhaitez représenter.\r\n\r\n\r\npng(\"barplot2.png\",\r\n    width = 1600, height = 600)\r\n\r\nbarplot(especes_menacees$comptage,\r\n        names.arg = c(\"En danger critique\",\r\n                      \"En danger\",\r\n                      \"Vulnerable\",\r\n                      \"Quasi-menacee\",\r\n                      \"Preoccupation mineure\"),\r\n        xlab = \"Niveau   de menace\", ylab = \"Nombre d'especes\",\r\n        ylim = c(0, 70),\r\n        cex.names = 1.5, cex.axis = 1.5, cex.lab = 1.5)\r\n\r\n\r\n\r\n\r\nIl existe une manière plus simple de préciser les étiquettes …\r\nBilan du tutoriel :\r\nVous vous êtes familiarisé avec l’interface RStudio\r\nVous savez comment créer et annoter un fichier de script\r\nVous pouvez importer vos propres données dans RStudio\r\nVous savez comment vérifier et explorer vos données\r\nVous pouvez générer des graphiques basiques et les exporter\r\nDéfi\r\nSi c’est votre premier contact avec R, ne vous inquiétez pas si vous ne comprenez pas tout, tout de suite. Revenez à tête reposée sur les parties que vous avez trouvées plus difficiles.\r\nVoici un petit défi pour mettre en pratique ce que vous avez vu dans ce tutoriel.\r\nVous verrez ci-dessous des données (fictives) de mesures d’envergure (en cm) pour quatre espèces différentes d’oiseaux. Essayez de créer un barplot de l’envergure moyenne pour chacune des espèces et sauvegardez-le sur votre ordinateur.\r\n\r\nIl vous faudra trouver une fonction permettant de calculer une moyenne\r\nespece\r\nenvergure (cm)\r\nAigle\r\n195\r\nChouette\r\n85\r\nColibri\r\n8\r\nMoineau\r\n24\r\nAigle\r\n201\r\nChouette\r\n102\r\nColibri\r\n9\r\nMoineau\r\n21\r\nAigle\r\n185\r\nChouette\r\n91\r\nColibri\r\n9\r\nMoineau\r\n22\r\nSolution\r\nNe regardez pas avant d’avoir essayé ! Il n’existe pas une seule solution possible, plusieurs façons de procéder amèneront au même résultat. Les noms des objets et l’apparence du graphique seront sans doute différents, et cela ne pose aucun problème - du moment que les valeurs elles-mêmes sont correctes.\r\n\r\n\r\nShow code\r\n\r\n# Extraire les envergures pour chaque espece\r\nenv_aigle <- c(195, 201, 185)\r\nenv_chouette <- c(85, 102, 91)\r\nenv_colibri <- c(8, 9, 9)\r\nenv_moineau <- c(24, 21, 22)\r\n\r\n# Calculer l'envergure moyenne\r\nenv_moy_aigle <- mean(env_aigle)\r\nenv_moy_chouette <- mean(env_chouette)\r\nenv_moy_colibri <- mean(env_colibri)\r\nenv_moy_moineau <- mean(env_moineau)\r\n\r\n# Rassembler ces valeurs moyennes dans un vecteur\r\nenv_moyenne <- c(env_moy_aigle, env_moy_chouette, env_moy_colibri, env_moy_moineau)\r\n\r\n# Creer un vecteur avec les noms des especes (attention à l'ordre !)\r\nespeces <- c(\"Aigle\", \"Chouette\", \"Colibri\", \"Moineau\")\r\n\r\n# Transformer ce vecteur en un facteur\r\nespeces_f <- as.factor(especes)\r\nclass(especes_f)\r\n\r\n# Combiner les deux vecteurs dans un data frame\r\nenvergure <- data.frame(especes_f, env_moyenne)\r\n\r\n# Sauvegarder le barplot dans un fichier\r\npng(\"barplot_envergure.png\",\r\n    width = 1600, height = 600)\r\n\r\nbarplot(envergure$env_moyenne,\r\n        names.arg = envergure$especes_f,\r\n        xlab = \"Espèces\", ylab = \"Envergure moyenne\",\r\n        ylim = c(0, 200),\r\n        cex.names = 1.5, cex.axis = 1.5, cex.lab = 1.5,\r\n        col = \"gold\")  # modifier la couleur des barres\r\n\r\ndev.off()\r\n\r\n\r\n\r\nGlossaire\r\n Voici quelques termes importants vus dans ce tutoriel :\r\nargument : élément d’une fonction, essentiel ou optionnel, qui précise ou modifie la façon dont la fonction est exécutée. Par exemple, il peut s’agir du chemin vers un fichier qui sera importé, ou de l’emplacement où sera sauvegardé un fichier : file = \"chemin-vers-le-fichier. Il peut aussi modifier les couleurs d’un graphique : col = \"blue\". Vous pouvez trouver une liste des arguments d’une fonction à l’aide de la commande ?nom-de-la-fonction.\r\nclasse : le type de données contenu dans une variable : habituellement des charactères (texte/mots), des nombres entiers ou relatifs, ou des facteurs (des valeurs de groupement, utiles quand vos données contiennent de multiples observations issues de différents sites ou traitements).\r\ncommande : un morceau de code qui exécute une action, contient généralement une ou plusieurs fonctions. Vous pouvez exécuter une commande en cliquant sur “Run” ou grâce aux raccourcis clavier comme Cmd + Entrée, Ctrl + Entrée ou Ctrl + R.\r\ncommentaire : un morceau de texte dans un script qui débute par un hashtag # et qui n’est pas lu comme une commande. Les commentaires rendent le code plus facilement lisible pour d’autres personnes : utilisez-les pour créer des sections dans votre script et pour annoter chaque étape de votre analyse.\r\nconsole : la fenêtre dans laquelle vous pouvez taper du code directement en ligne de commande (2+2 puis Entrée retournera 4), et où les résultats des commandes seront affichés.\r\ndata frame : un type d’objet R composé de nombreuses lignes et colonnes (pensez à une feuille Excel). Généralement les colonnes contiennent différentes variables (par exemple âge, couleur, poids, envergure), et les lignes les observations de ces variables (par exemple oiseau1, oiseau2, oiseau3).\r\nespace de travail : c’est votre environnement de travail virtuel, il contient toutes les fonctions des packages que vous avez chargés, les objets que vous avez créés, et ainsi de suite. Il est préférable de démarrer une session de travail avec un espace de travail vide.\r\nfichier csv : un type de fichier couramment utilisé pour importer des données dans R, où les valeurs des différentes variables sont compressées (une chaîne, ou une ligne de valeurs par ligne) et séparées seulement par des virgules (indiquant les colonnes). R peut aussi lire des fichiers Excel (.xlsx), mais cela n’est pas recommandé car il est difficile d’éviter les erreurs de formatage.\r\nfonction : du code qui exécute une action, c’est-à-dire tout ce que vous faites dans R. Une fonction prend une entrée, la modifie d’une façon ou d’une autre, et retourne une sortie (un objet, un résultat de test, un fichier, un graphique). Il existe des fonctions pour importer, convertir et manipuler des données, pour effectuer des calculs spécifiques (essayez de deviner ce que retourneraient les fonctions min(10, 15, 5) et max(10, 15, 5)), générer des graphiques, et bien davantage.\r\nobjet : les briques de construction de R. Si R était un langage parlé, les fonctions seraient les verbes (actions) et les objets les noms (les sujets ou les objets de ces actions). On fait appel à un objet par son nom sans guillemets. Les objets permettent de stocker des données, et prennent différentes formes. Les objets les plus courants sont les data frames et les vecteurs, mais il en existe d’autres, comme les listes et les matrices.\r\npackage : un ensemble de fonctions qui apportent des fonctionnalités supplémentaires à R. De nombreux packages sont inclus dans R, d’autres peuvent être téléchargés pour des besoins spécifiques.\r\nrépertoire de travail : le dossier sur votre ordinateur associé à votre session R actuelle, contenant les données que vous allez importer et où vous sauvegarderez des fichiers. Vous pouvez le définir au début de votre session à l’aide de la fonction setwd().\r\nscript : comme un éditeur de texte, un script vous permet d’écrire votre code et de le sauvegarder pour des usages futurs. Il contient un mélange de code et de commentaires et est sauvegardé comme un simple fichier texte que vous pouvez aisément partager pour que n’importe qui puisse reproduire votre travail.\r\nvecteur : un type d’objet R qui ne contient qu’une seule dimension : il stocke une ligne de valeurs qui peuvent être des caractères, des nombres, etc.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/premiers-pas-avec-r/img/happy-r.png",
    "last_modified": "2022-05-13T15:39:39+02:00",
    "input_file": {}
  }
]
