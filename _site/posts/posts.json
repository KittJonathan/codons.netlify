[
  {
    "path": "posts/les-bases-de-la-manipulation-de-donnes/",
    "title": "Les bases de la manipulation de données",
    "description": "Sélectrionner, modifier et mettre en forme vos données.",
    "author": [
      {
        "name": "Sandra Angers-Blondin",
        "url": "https://ourcodingclub.github.io/tutorials/data-manip-intro"
      },
      {
        "name": "Jonathan Kitt (adaptation)",
        "url": {}
      }
    ],
    "date": "2022-05-02",
    "categories": [
      "R",
      "RStudio",
      "Données",
      "Tidyverse"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nLa syntaxe basique de R\r\nLes données tidy\r\nLes fonctions principales de dplyr\r\n\r\nCe tutoriel est adapté de Basic data manipulation du site Our Coding Club.\r\nIntroduction\r\n\r\n\r\n\r\nDessin de Allison Horst\r\n\r\nLes objectifs de ce tutoriel sont les suivants :\r\nApprendre à manipuler des données à l’aide des opérateurs basiques de R\r\nNettoyer des données avec le package tidyr\r\nManipuler ses données à l’aide du package dplyr\r\n\r\nVoici les étapes que nous allons suivre pour y parvenir :\r\nSélectionner, extraire et modifier des données avec les opérateurs basiques de R\r\nComment nettoyer des données\r\nExplorer les principales fonctions de dplyr\r\nrename()\r\nfilter() et select()\r\nmutate()\r\ngroup_by()\r\njoin()\r\n\r\nDéfi\r\n\r\nUn format de données qui s’avère utile et pratique pour une application spécifique ne le sera pas forcément pour une autre application. Les fonctions de R nécessitent un certain format et un certain type de données, ce qui rend la maîtrise de la mise en forme de données essentielle !\r\n\r\nSi vous avez besoin de revoir les bases de R, vous pouvez lire le tutoriel Premiers pas avec R.\r\n\r\nDans ce tutoriel, nous allons voir comment manipuler des données en utilisant la syntaxe basique de R (vous verrez souvent des solutions en ligne avec cette syntaxe). Nous introduirons ensuite le concept de données tidy, très utiles pour la collecte et l’organisation de données. Nous utiliserons ensuite des packages du Tidyverse, qui est en train de devenir la norme pour les data sciences, qui permet de coder de façon plus claire et nette que les fontions basiques de R.\r\n\r\nCliquez sur ce lien pour télécharger le dossier contenant tous les fichiers dont vous aurez besoin pour ce tutoriel (rappel sur la procédure ici).\r\n\r\n\r\n\r\nLa syntaxe basique de R\r\nLes data frames sont des objets qui contiennent des observations (dans les lignes) de différentes variables (dans les colonnes). Commençons par importer le fichier croissance.csv dans le dossier que vous avez téléchargé.\r\nCréez un nouveau script, ajoutez des informations (date, titre, …) en haut du script (à l’aide de #).\r\nCe jeu de données représente la croissance annuelle de tiges d’arbrisseaux (Empetrum nigrum ou camarine noire) situés dans des dunes de sables. La colonne Zone correspond à des zones distinces allant de la plus proche (2) à la plus éloignée (7) de la mer.\r\nEmpetrum nigrumNous avons vu dans le tutoriel d’introduction à R comment accéder à des variables à l’aide du signe dollar $. Cette manière de sélectionner permet de réduire un data frame en deux dimensions en un vecteur à une dimension. Une autre manière de sélectionner des parties d’un data frame est d’utiliser des crochets : [x , y] sélectionnera la ligne x et la colonne y. Un espace blanc à gauche ou à droite de la virgule permet de sélectionner respectivement toutes les colonnes ou toutes les lignes du data frame.\r\n\r\n\r\n# Definir le repertoire de travail\r\nsetwd(\"C:/Users/ateliers/codons_02_bases_manipulation_donnees/\")\r\n\r\n# Importer les donnees \r\ncroissance <- read.csv(\"croissance.csv\")\r\n\r\n# Explorer les donnees\r\nhead(croissance)  # affiche les premieres observations\r\nstr(croissance)  # affiche les types des variables\r\ncroissance$Indiv  # affiche tous les identifiants de la variable \"Indiv\"\r\nlength(unique(croissance$Indiv))  # nombre d'abrisseaux dans le jeu de données\r\n\r\n# Selectionner des donnees\r\ncroissance[2, 5]  # 2e ligne et 5e colonne\r\ncroissance[6, ]  # 6e ligne\r\ncroissance[6, ]$Indiv  # colonne Indiv pour la 6e ligne\r\n\r\n\r\n\r\nLa sélection à l’aide des crochets peut se révéler fastidieuse si vous travaillez sur un large jeu de données et que vous ne savez pas où se trouvent les observations qui vous intéressent. Cette façon de faire n’est pas recommandée, car si vous inscrivez des nombres dans votre code et que vous ajoutez des colonnes par la suite, il n’est pas impossible que votre sélection soit modifiée. C’est pour cette raison qu’il est préférable d’utiliser des opérations logiques pour sélectionner les parties des données qui répondent à nos critères.\r\n\r\n\r\n# Selectionner les valeurs pour l'individu n°603\r\ncroissance[croissance$Indiv == 603, ]\r\n\r\n\r\n\r\nDécortiquons cette commande : dans le data frame croissance, R va sélectionner ([ , ]) les lignes (expression à gauche de la virgule) pour lesquelles la valeur dans la colonne “Indiv” ($Indiv) est strictement égale à (==) 603. L’expression logique fonctionne car la colonne Indiv contient des valeurs numériques. Pour sélectionner des données de type caractère ou facteur, il faudrait utiliser des guillemets : croissance$Indiv == \"six-cent-trois\".\r\nOpérateurs logiques\r\n== : strictement égal<, <= : inférieur à, inférieur ou égal à>, >= : supérieur à, supérieur ou égal à!= : différent de%in% : appartient à (suivi d’un vecteur de valeurs possibles)& : et| : ou! : n’appartient pas à\r\n\r\n\r\n# Une condition\r\ncroissance[croissance$Zone < 4, ]  # zones 2-3\r\ncroissance[croissance$Zone <= 4, ]  # zones 2-3-4\r\ncroissance[!croissance$Zone >= 5, ]  # meme chose que la commande precedente\r\n\r\n# Deux conditions\r\ncroissance[croissance$Zone == 2 | croissance$Zone == 7, ]  # zones 2 et 7\r\ncroissance[croissance$Zone == 2 & croissance$Indiv %in% c(300:400), ]  # zone 2 et ID entre 300 et 400\r\n\r\n\r\n\r\nComme vous pouvez le voir, le code s’alourdit avec des conditions plus exigeantes. Nous verrons que des fonctions permettent d’alléger le code, mais il sera parfois nécessaire d’utiliser cette syntaxe basique, notamment pour des objets de type data frame.\r\nRevenons sur le bout de code c(300:400). Nous avons vu dans notre tutoriel d’introduction à R que c() permet de concaténer des éléments dans un vecteur. Les : entre 300 et 400 permet de compter de 300 à 400.\r\nIl existe d’autres façons de construire une séquence :seq() permet de créer une séquence par incrément (par ex. seq(300, 400, 10)).rep() permet de répéter des éléments : rep(c(1, 2), 3) donnera 1 2 1 2 1 2.\r\nVous pouvez mélanger ces deux fonctions : que donnera rep(seq(0, 30, 10), 4) ?\r\n\r\nCréer et écraser des objets\r\nNous avons utilisé <- pour créer de nouveaux objets, ce qui permet de choisir un nom et de l’assigner à un objet (vecteur, liste, data frame, …).\r\nGardez à l’esprit que si vous utilisez un même nom dans la même session, l’objet d’origine sera écrasé. Avec un peu de pratique, vous pourrez modifier un objet et l’écraser au fur et à mesure, pour le “mettre à jour” plutôt que de créer de multiples intermédiaires (“objet1”, “objet2”, …).\r\nIl est préférable, pour débuter, de créer des objets intermédiaires ou tout du moins une “copie de travail” que vous pourrez ré-assigner à l’objet d’origine quand vous serez satisfait des modifications.\r\nNous allons voir maintenant comment utiliser la flèche <- pour écraser des valeurs après modification.\r\n\r\n\r\n# Creer une copie de travail de l'objet\r\ncroissance2 <- croissance\r\n\r\n# Afficher les noms de colonnes\r\nnames(croissance2)\r\n\r\n# Modifier le nom de la premiere colonne : \"Zone\" devient \"zone\"\r\nnames(croissance2)[1] <- \"zone\"\r\n\r\n# Modifier le nom de la deuxieme colonne : \"Indiv\" devient \"ID\"\r\nnames(croissance2)[2] <- \"ID\"\r\n\r\n# Modifier la valeur 5.1 pour l'individu 373 en 2008 par 5.7\r\n# Option 1\r\ncroissance2[1, 4] <- 5.7\r\n# Option 2\r\ncroissance2[croissance2$ID == 373, ]$X2008 <- 5.7\r\n#\r\n\r\n\r\n\r\nL’option 1 est plus compacte, mais nécessite de savoir précisément où se situe la valeur à modifier.\r\nL’option 2 est plus longue et difficile à lire mais permet un contrôle plus fin.\r\n\r\nEn procédant de la même manière, vous pouvez spécifier les classes de variables :\r\n\r\n\r\n# Afficher les classes des variables\r\nstr(croissance2)\r\n\r\n# La variable \"zone\" contient des valeurs numériques mais il s'agit d'une variable de groupement\r\n# Transformons cette variable en un facteur\r\ncroissance2$zone <- as.factor(croissance2$zone)\r\nstr(croissance2)\r\n\r\n\r\n\r\nVous pouvez également spécifier les niveaux du facteur :\r\n\r\n\r\n# Afficher les niveaux d'un facteur\r\nlevels(croissance2$zone)\r\n\r\n# Modifier les niveaux (attention à l'ordre et au nombre de niveaux !)\r\nlevels(croissance2$zone) <- c(\"A\", \"B\", \"C\", \"D\", \"E\")\r\n\r\n\r\n\r\nLes données tidy\r\nQuand vous mesurez des données dans les champs ou au laboratoire, vous souhaitez avoir des tableaux préparés à l’avance à remplir au fur et à mesure. Par exemple, si vous mesurez la hauteur de semis au cours d’une expérimentation visant à mesurer les effets de la température et de la fertilisation, vous pourriez utiliser le tableau suivant :\r\n\r\n\r\n\r\nSi vous savez comment votre expérimentation a été menée, R n’en sait rien ! Dans l’état actuel, avec 8 mesures par ligne, vous ne pouvez pas analyser les données. Les *données tidy sont arrangées de telle sorte que chaque ligne représente une observation et chaque colonne représente une variable. Dans notre cas, voici à quoi ressemblerait des données tidy** :\r\n\r\n\r\n\r\nCe format de tableau comporte plus de lignes, raison pour laquelle on parle de format long (le premier tableau ci-dessus est au format large). Si vous souhaitez comparer des groupes, des traitements, des espèces, etc., R pourra ainsi séparer les données correctement, chaque facteur de groupement ayant sa propre colonne. Notre objet croissance n’est pas au format tidy : les observations d’une même variable, la croissance de la tige, est répartie sur plusieurs colonnes, avec une colonne par année.\r\n La fonction pivot_longer() du package tidyr permet de convertir un tableau d’un format large en un format long. Nous allons pour cela créer une colonne Annee qui contiendra les valeurs des années (2007 à 2012) répétées pour chaque individu. Le tableau ainsi obtenu aura donc six fois plus de lignes que le tableau d’origine. Nous allons également créer une colonne Croissance qui contiendra les données associées à la croissance pour chaque année et chaque individu.\r\nCommençons par installer et charger le package tidyr\r\n\r\n\r\ninstall.packages(\"tidyr\")\r\nlibrary(tidyr)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncroissance_long <- pivot_longer(\r\n  data = croissance,  # objet a transformer\r\n  cols = c(X2007, X2008, X2009, X2010, X2011, X2012),  # colonnes a regrouper\r\n  names_to = \"Annee\",  # les annees sont regroupees dans cette colonne\r\n  values_to = \"Croissance\")  # les valeurs mesurees sont regroupees dans cette colonne\r\n\r\n\r\n\r\nLa fonction pivot_wider() permet d’effectuer l’opération inverse :\r\n\r\n\r\ncroissance_large <- pivot_wider(\r\n  data = croissance_long,  # objet a transformer\r\n  id_cols = c(Zone, Indiv),  # colonnes contenant les identifiants\r\n  names_from = Annee,  # cette colonne sert a creer les noms de colonnes\r\n  values_from = Croissance)  # cette colonne sert a remplir les colonnes\r\n\r\n\r\n\r\nNous avons utilisé les noms des colonnes pour indiquer à pivot_longer() quelles colonnes transformer. Cela est pratique si votre jeu de données ne comporte que quelques colonnes. Si votre jeu de données comporte un grand nombre de colonnes (par exemple 100 gènes), il est préférable de spécifier les colonnes par leurs positions :\r\n\r\n\r\ncroissance_long2 <- pivot_longer(\r\n  data = croissance,\r\n  cols = c(3:8),\r\n  names_to = \"Annee\",\r\n  values_to = \"Croissance\")\r\n\r\n\r\n\r\nCes fonctions ont cependant des limites et ne fonctionnent pas avec toutes les structures de données. Pour citer Hadley Wickham (directeur scientifique pour RStudio et l’un des créateurs du tidyverse) : “chaque jeu de données désordonné est désordonné à sa façon”. Réfléchir en amont à la structure de vos données peut vous éviter beaucoup de frustrations par la suite !\r\nUne fois que vos données sont au bon format, leur analyse et la visualisation des résultats sera plus simple. Par exemple, si nous souhaitons savoir s’il y a une variation inter-annuelle dans la croissance de Empetrum hermaphroditum, nous pouvons rapidement créer un boxplot :\r\n\r\n\r\nboxplot(Croissance ~ Annee, data = croissance_long,\r\n        ylab = \"Croissance (cm)\",\r\n        main = \"Croissance annuelle de Empetrum hermaphroditum\")\r\n\r\n\r\n\r\n\r\nLe graphique montre un chevauchement assez important entre les valeurs de croissance par année - pas grand chose à signaler de ce point de vue-là !\r\nLes fonctions principales de dplyr\r\nLe package dplyr contient des fonctions intuitives pour la manipulation de données, nommées d’après l’action qu’elles accomplissent. Ces fonctions ont l’avantage de prendre comme premier argument le data frame, ce qui permet de se référer à des colonnes sans se référer à l’objet entier (vous pouvez donc laisser tomber les signes $ !). Nous allons voir les fonctions les plus courantes et utiles pour manipuler le tableau au format long qu’on vient tout juste de créer, croissance_long. Commençons par charger le package.\r\n\r\n\r\nlibrary(dplyr)\r\n\r\n\r\n\r\nRenommer des variables avec rename()\r\n\r\n\r\n\r\n",
    "preview": "posts/les-bases-de-la-manipulation-de-donnes/img/data_cowboy.png",
    "last_modified": "2022-05-03T17:16:38+02:00",
    "input_file": {}
  },
  {
    "path": "posts/premiers-pas-avec-r/",
    "title": "Premiers pas avec R",
    "description": "Débuter avec R et RStudio.",
    "author": [
      {
        "name": "Gergana Daskalova",
        "url": "https://ourcodingclub.github.io/tutorials/intro-to-r/"
      },
      {
        "name": "Jonathan Kitt (adaptation)",
        "url": {}
      }
    ],
    "date": "2022-05-02",
    "categories": [
      "R",
      "RStudio",
      "Introduction"
    ],
    "contents": "\n\nContents\nIntroduction\nTélécharger R et RStudio\nImporter et vérifier les données\nCompter le nombre d’espèces menacées\nCréer un vecteur et le représenter\nCréer un dataframe et le représenter\nDéfi\nGlossaire\n\n\n\n\nCe tutoriel est adapté de Getting\nstarted with R and RStudio du site Our Coding Club.\n\n\n\nDessin de Allison\nHorst\nIntroduction\n\nLes objectifs de ce tutoriel sont les suivants :\nComprendre ce qu’est R (et RStudio)\nPrendre la bonne habitude de travailler avec des scripts\nApprendre à importer des données dans R\nApprendre à manipuler des objets (vecteurs et data frames)\nCréer un graphique basique\nVoici les étapes que nous allons suivre pour y\nparvenir :\nTélécharger R et RStudio\nImporter et vérifier les données\nCompter le nombre d’espèces menacées\nCréer un vecteur et le représenter\nCréer un data frame et le représenter\nDéfi\nGlossaire\nQu’est-ce que R?\nR est un langage de programmation statistique qui a\nrapidement gagné en popularité dans de nombreux domaines scientifiques.\nIl a été développé par Ross Ihaka et Robert\nGentleman comme implémentation libre du langage de\nprogrammation S.\n\nR désigne également le logiciel qui utilise ce\nlangage pour des calculs statistiques. Il dispose d’une\ncommunauté en ligne très active ainsi que\nd’extensions pour presque tous les domaines et\napplications possibles et imaginables.\n\nContrairement à d’autres logiciels de statistiques comme Minitab ou\nSPSS, R peut être exécuté entièrement en ligne de\ncommande et ne nécessite pas d’interface graphique, ce qui lui\nconfère une grande flexibilité.\n\nVoici quelques avantages de R :\nC’est un outil libre et open source (tout le monde\npeut utiliser le code et voir comment il fonctionne)\nC’est un langage de programmation plutôt qu’une interface graphique,\nce qui permet à l’utilisateur de sauvegarder facilement des\nscripts sous forme de texte pour les ré-utiliser ou les\npartager\nBeaucoup de personnes l’utilisent dans beaucoup de domaines\ndifférents - il est rare d’être confronté à un problème qui n’a\njamais été résolu !\n\nTélécharger R et RStudio\nLa plupart des utilisateurs interagissent avec R à l’aide d’une\ninterface graphique, dont la plus connue est\nRStudio. RStudio permet d’avoir accès dans une seule\nfenêtre à vos scripts, à vos données,\nà vos graphiques, à vos résultats,\nainsi qu’à de l’aide.\n\nTéléchargez R sur le site du\nCRAN (The Comprehensive R Archive Network)\nTéléchargez RStudio (“free open\nsource desktop version”)\nSur Mac, vous aurez également besoin de XQuartz\n\nOuvrez RStudio, puis cliquez sur “File / New File / R\nscript”\n\n\n\nVous verrez une fenêtre comme celle ci-dessus, avec quatre panneaux\n:\n1) La console : vous pouvez y taper du code et\nl’exécuter avec Entrée.\n\nEssayez de taper et d’exécuter 2+2\n2) Le script : vous pouvez - et c’est préférable - y\ntaper du code. Pour l’exécuter, placez-vous à la fin de la ligne et\nutilisez la combinaison de touches Ctrl + R (Windows) ou\nCmd + Entrée (Mac).\n\nSur les ordinateurs avec une version récente de Windows,\nCtrl + Entrée\n3) L’environnement : aperçu de votre espace de\ntravail (données importées, objets créés, fonctions définies, …).\n4) Fichiers / Graphiques / Packages / Aide : permet\nde naviguer dans vos dossiers, de visualiser vos graphiques, de voir\nquels packages sont installés et chargés, et d’obtenir de l’aide.\nA propos des scripts :  gardez bien à l’esprit\nque le code tapé directement dans la console ne sera pas sauvegardé par\nR : il disparaît une fois exécuté (vous pouvez toutefois accéder aux\ndernières commandes à l’aide de la touche Flèche du haut de\nvotre clavier). L’utilisation d’un script pour taper votre code vous\npermet d’en garder une trace. C’est un peu comme quand vous rédigez un\ndocument dans Word : vous pouvez sauvegarder votre progression pour\nreprendre là où vous en étiez, ou faire des modifications. Lorsque vous\ntapez du code dans un script, pensez à le sauvegarder régulièrement\n(Ctrl + S).\nIl est fortement recommandé d’ajouter à votre code des commentaires\ndécrivant les étapes. Pour cela, insérez un hashtag (#)\ndevant une ligne de votre script (ou Ctrl + Shift + C).\nToutes les lignes qui commencent par un # seront\nconsidérées par R comme du texte et non du code, et ne seront pas\nexécutées. Ces commentaires apporteront des informations précieuses pour\ntoute personne qui lira votre script (y compris vous-même quand vous\nreviendrez dessus dans un certain temps !). Comme tout document écrit,\nles scripts sont plus facilement lisibles quand ils sont bien structurés\net clairs.\nA propos de l’espace de travail :  votre espace de\ntravail contient tout ce que vous utilisez lors d’une session R. En\nquittant R, vous aurez le choix de sauvegarder ou non cet espace de\ntravail. Il est préférable de ne pas le faire et de démarrer chaque\nsession avec en espace de travail vide. \nTéléchargez les données\nLa meilleure façon d’apprendre un nouveau langage est de le\npratiquer. Nous allons analyser une liste d’espèces\nd’oiseaux menacées en Auvergne (données de 2015 obtenues sur le site de\nla DREAL).\nCes données se trouvent dans un fichier appelé\noiseaux.csv.\n1) Créez un nouveau dossier sur votre ordinateur :\nvous allez y télécharger les données, et vous pourrez y sauvegarder\nvotre script et vos graphiques. Choisissez un nom explicite, par exemple\ncodons_01_intro_r\n\nEvitez les espaces vides dans vos noms de dossiers !\n2) Cliquez sur ce\nlien pour télécharger le fichier\noiseaux.csv\n3) Cliquez sur “Code” puis “Download ZIP” (voir\nci-dessous)\n\n\n\n4) Choisissez comme emplacement de sauvegarde le dossier que\nvous venez de créer\n5) Dézippez le dossier\nCommencez à écrire votre\nscript\nPour l’instant, vous pouvez noter la date et l’objectif du tutoriel -\ncompter le nombre d’espèces d’oiseaux menacées d’extinction en Auvergne.\nVous pouvez copier l’exemple ci-dessous pour le coller et l’éditer dans\nvotre propre script :\n\n\n# Ateliers codon(s)!\n# 01 - Premiers pas avec R\n# Lundi 09/05/2022\n\n\n\nLes lignes suivantes dans votre script servent généralement à charger\nles packages dont vous aurez besoin pour votre analyse.\nUn package contient des commandes qui peuvent être chargées dans R pour\napporter des fonctionnalités supplémentaires (il existe par exemple des\npackages pour formater des données ou pour créer des cartes).\nUn package doit tout d’abord être téléchargé et\ninstallé sur votre ordinateur à l’aide de la commande\ninstall.packages(\"nom-du-package\") avant d’être\nchargé pour être utilisé à l’aide de la commande\nlibrary(nom-du-package). Un package n’a besoin d’être\ninstallé qu’une seule fois, vous pouvez donc le faire directement dans\nla console plutôt que de sauvegarder la ligne de code dans votre script\net d’ainsi le ré-installer à chaque fois que vous exécutez votre script.\nNous allons utiliser le package dplyr qui\nfournit des fonctionnalités supplémentaires pour la manipulation et le\nformatage de données.\n\nNotez bien la présence de guillemets autour du nom du package dans\nl’appel à la fonction install.packages(), et leur absence\ndans l’appel à la fonction library()\n\n\ninstall.packages(\"dplyr\")\nlibrary(dplyr)\n\n\n\nNous allons maintenant définir notre répertoire de\ntravail - le dossier dans lequel R cherchera les données à\nimporter et sauvegardera les graphiques. C’est dans notre cas le dossier\ndans lequel nous avons téléchargé les données.\nQuand vous aurez à travailler sur des projets plus importants, vous\npourrez tout à fait créer un dossier racine (par ex.\n“nom_du_projet/”), le définir comme répertoire de travail, et créer des\nsous-dossiers pour organiser les fichiers (par ex.\n“nom_du_projet/donnees_brutes/”, “nom_du_projet/figures/”, …).\nPour afficher le réperoire de travail, utilisez la commande\ngetwd() (pour get working directory). La commande\nsetwd(\"nom-du-repertoire-de-travail\") (set working\ndirectory) permet de définir un nouveau répertoire de travail.\n\nFaites attention au sens des slashes dans vos chemins de\ndossiers !\n\n\nsetwd(\"C:/User/Codons-01-PremiersPasAvecR\")\n# Remplacez le chemin ci-dessus par le votre\n\n\n\n\nL’auto-complétion est votre alliée ! Tapez quelques lettres puis sur la\ntouche Tab et R complètera pour vous.\nImporter et vérifier les données\nPour importer les donées dans RStudio, deux options s’offrent à vous\n:\nCliquer sur le bouton Import Dataset\n\n\n\nIndiquez quel fichier vous souhaitez importer, et RStudio vous\nproposera un aperçu de vos données. Assurez-vous qu’à côté de\nHeading vous avez sélectionné Yes (ceci indique à R\nqu’il doit considérer la première ligne de vos données comme des noms de\ncolonnes). Cliquez enfin sur Import.\n\n\n\nDans la console vous verrez le code utilisé pour importer vos\ndonnées, y compris le chemin vers votre fichier - il est utile de copier\ncette ligne de code et de la coller dans votre script, pour que vous\nsachiez d’où vient votre jeu de données.\nVous remarquerez que le chemin vers votre fichier débute par\nC:/. Il s’agit du chemin absolu vers le\nfichier à importer, qui ne tient pas compte du fait que vous avez défini\nun répertoire de travail. Vous pouvez également utiliser le\nchemin relatif qui indique l’emplacement du fichier à\npartir de votre répertoire de travail (voir ci-dessous)\nUtiliser la commande read.csv() : R\nfonctionne mieux avec des fichiers .csv (valeurs séparées\npar des virgules). Si vous travaillez dans Excel, cliquez sur\nEnregistrer sous et choisissez csv comme extension\nde fichier.\n\nDans Excel, évitez les espaces dans vos noms de colonnes (ex :\nnom_latin plutôt que nom latin)\nCertains ordinateurs utilisent le point-virgule ; comme\nséparateur dans les fichiers .csv. Vous pouvez dans ce cas\nutiliser la fonction read.csv2(), ou préciser dans la\nfonction read.csv() l’argument sep = \";\".\n\n\noiseaux <- read.csv(\"Codons-01-PremiersPasAvecR-main/oiseaux.csv\")\n# modifiez le chemin vers le fichier si nécessaire\n\n\n\nA propos des objets : R est langage orienté\nobjet - cela signifie que tout ce que vous importez et créez est stocké\ndans des objets que vous allez nommer. Ici, nous avons assigné le\nfichier oiseaux.csv à l’objet oiseaux à l’aide\nde la flèche <-. Nous aurions tout à fait pu l’appeler\nmesdonnees ou oiseaux_liste_rouge_auvergne,\nmais il est préférable de choisir un nom unique, informatif et court.\nDans le panneau Environment de RStudio vous pouvez voir les\nnoms de tous les objets actuellement chargés dans R. Assurez-vous que\nvous voyez bien l’objet oiseaux.\nQuand vous importez vos données dans R, il est très probable qu’elles\ndeviennent un objet qu’on appelle un data frame : un tableau contenant\ndes lignes (observations) et des colonnes (variables).\nUne des premières choses à faire est de vous assurer que vos\ndonnées ont été importées sans erreur. Il est recommandé de\ntoujours exécuter ce code dans la console et de vérifier le résultat -\nvoyez-vous des erreurs, est-ce que les nombres/noms ont du sens ? Si\nvous passiez directement à l’analyse, vous risqueriez de vous rendre\ncompte plus tard que R n’a pas importé vos données correctement et vous\ndevriez recommencer, ou pire, vous pourriez analyser de mauvaises\ndonnées sans vous en rendre compte. Pour visualiser davantage que les\nquelques premières lignes, vous pouvez également cliquer sur l’objet\ndans le panneau Environment, ce qui affichera un tableau dans\nun nouvel onglet à côté de votre script. Des fichiers peuvent être trop\nlarges pour êtres affichés entirement, gardez donc à l’esprit qu’il peut\ny avoir des lignes ou des colonnes manquantes.\n\n\nhead(oiseaux)  # affiche les premières lignes\ntail(oiseaux)  # affiche les dernières lignes\nstr(oiseaux)  # affiche le type de variables\n\n\n\nLa commande str(nom.objet) affiche la structure de vos\ndonnées. Très souvent, les analyses ne se déroulent pas comme prévu car\nR s’est trompé de type de variable. Imaginez que vos données comportent\nquatre groupes d’étude appelés “1, 2, 3, 4”. Vous savez pertinnement\nqu’il s’agit d’une variable catégorique (un facteur),\nmais R peut considérer qu’il s’agit d’une variable numérique.\n\nPensez toujours à vérifier la structure de vos données !\nLa fonction str(oiseaux) nous indique que la variable\ncategorie est une chaîne de caractères (chr). Nous\npréférerions que R considère cette variable comme étant catégorique - un\nfacteur. Nous allons le préciser en accédant à la colonne concernée à\nl’aide du signe dollar $ :\n\n\nhead(oiseaux$categorie)  # premiers éléments de la variable\nclass(oiseaux$categorie)  # type de variable\noiseaux$categorie <- as.factor(oiseaux$categorie)\n\n\n\nLa dernière ligne du code ci-dessus permet de transformer la variable\ncategorie en un facteur. La fonction\nas.factor(oiseaux$categorie) toute seule serait exécutée,\nmais ne modifierait pas les données stockées dans l’objet\noiseaux. Il faut pour cela ré-assigner cette variable\ntransformée en facteur à la variable d’origine. Pour vous assurer que\nl’opération a bien fonctionné, vous pouvez exécuter à nouveau la\nfonction class(oiseaux$categorie).\nLes fonctions suivantes permettent d’explorer autrement vos données\n:\n\n\ndim(oiseaux)  # dimensions de l'objet\nsummary(oiseaux)  # synthèse de l'objet\nsummary(oiseaux$categorie)  # synthèse de la variable\n\n\n\nCompter le nombre d’espèces menacées\nNotre objet oiseaux dresse une liste des espèces\nd’oiseaux menacées d’extinction en Auvergne, avec différents niveaux de\npréoccupation.\nNous allons compter le nombre d’espèces pour chaque\nniveau de préoccupation et créer une\nvisualisation de ce comptage.\nCommençons par séparer oiseaux en plusieurs objets, un\npour chaque niveau de menace, à l’aide de la fonction\nfilter() du package dplyr.\n\n\nen_danger_critique <- filter(oiseaux, categorie == \"En danger critique\")\n# Le 1er argument de la fonction est le data frame, \n# Le 2e argument est la condition à appliquer au filtre\n\n\n\n\nL’opérateur == permet de sélectionner les\nvaleurs “strictement égales à”\nR est sensible à la casse :\nfilter(oiseaux, categorie == \"en danger critique\") ne\nfonctionnera pas !\nProcédons de la même façon pour chaque catégorie. Si vous avez un\ndoute sur le nom ou l’orthographe d’une des catégories, pensez à la\nfonction summary(oiseaux$categorie).\nUne fois que vous avez créé tous les objets, vous allez pouvoir\ncompter le nombre d’espèces pour chaque catégorie. Nous\nallons pour cela imbriquer deux fonctions : unique() (pour\nidentifier chaque espèce) et length() (pour les\ncompter).\n\nVous pouvez essayer ces deux fonctions séparément dans la console\n\n\na <- length(unique(en_danger_critique$nom_francais))\n# choisissez des noms pratiques pour vos objets\n# \"a\" n'est peut-être pas le plus explicite ...\n\n\n\nProcédez de la même façon pour toutes les catégories. Cette manière\nde procéder peut vous sembler rébarbative … Nous verrons dans un\nprochain tutoriel comment procéder de manière plus efficace !\nTapez dans la console le nom d’un des objets que vous venez de créer.\nQue vous retourne-t-elle ?\nCréer un vecteur et le représenter\nNous allons maintenant combiner tous ces objets dans un\nvecteur - un objet à une dimension (à la différence\nd’un data frame qui en possède deux).\nNous utilisons pour cela la fonction c() (pour\nconcaténer), ainsi que la fonction names() pour\najouter des étiquettes aux valeurs.\n\n\ncomptage_especes <- c(a,b, c, d, e)\nnames(comptage_especes) <- c(\"En danger critique\",\n                             \"En danger\",\n                             \"Vulnerable\",\n                             \"Quasi-menacee\",\n                             \"Preoccupation mineure\")\n\n\n\n\nAttention à garder le même ordre !\nNotes :\n- Les espaces avant et après la flèche <- et après la\nvirgule , facilitent la lecture du code\n- Faites attention à vérifier que les valeurs du vecteur correspondent\nbien aux étiquettes - vous ne voudriez pas inverser les espèces “En\ndanger critique” avec les espèces “Quasi-menacées”! L’utilisation d’un\nscript permet de revenir sur le code et de vérifier qu’on ne s’est pas\ntrompé. Une bonne pratique serait de nommer les objets de façon plus\nexplicite, comme nb_en_danger_critique,\nnb_en_danger, …\n- Si vous cliquez à l’aide de la souris après une parenthèse, RStudio\nsurlignera la parenthèse lui correspondant. Les parenthèses manquantes,\nen particulier quand vous utilisez des fonctions imbriquées comme vous\nl’avez fait avec length(unique()) sont une des sources de\nfrustration et d’erreur les plus courantes quand vous commencez à coder\n!\nNous pouvons maintenant visualiser le nombre d’espèces par\ncatégorie à l’aide de la fonction barplot(). Les\ngraphiques s’affichent dans le panneau inférieur droit de RStudio.\n\n\nbarplot(comptage_especes)\n\n\n\nEt voilà votre premier graphique avec R ! Mais il y a des\nchoses à modifier : il manque des titres aux axes, toutes les\nétiquettes ne sont pas visibles, et la valeur pour les espèces dans la\ncatégorie “Préoccupation mineure” (n = 68) dépasse la plus grande valeur\naffichée sur l’axe Y.\nPour savoir comment apporter ces modifications à votre graphique,\nutilisez la fonction help(barplot) ou ?barplot\npour afficher l’aide de la fonction. Survolez le document qui s’affiche\net essayez de trouver des solutions.\n\n\nhelp(barplot)  # aide de la fonction barplot\nhelp(par)  # aide pour les graphiques\n\n\n\nNous aimerions également sauvegarder notre graphique. Là encore, vous\navez deux options : - Cliquer sur Export dans\nle panneau des graphiques : choisissez où sauvegarder le graphique (par\ndéfaut dans votre répertoire de travail) et modifiez le nom du fichier\npour qu’il soit plus explicite que Rplot01.png. Vous pouvez\naussi ajuster les dimensions de la figure.\n\n\n\nUtiliser les fonctions png() et\ndev.off() qui servent respectivement à ouvrir et\nfermer l’outil graphique :\n\n\npng(\"barplot.png\",\n    width = 1600, height = 600)\n\nbarplot(comptage_especes,\n        xlab = \"Niveau de menace\", ylab = \"Nombre d'espèces\",\n        ylim = c(0, 70),\n        cex.names = 1.5, cex.axis = 1.5, cex.lab = 1.5)\n\ndev.off()\n\n\n\n\nL’argument cex permet d’augmenter (> 1) ou de diminuer\n(< 1) la taille du texte\n\n\n\nCréer un dataframe et le représenter\nNous avons travaillé jusqu’ici avec des vecteurs, un\ntype d’objet bien adapté quand on manipule une seule série de valeurs à\nla fois. Dans la pratique, nous manipulons souvent plusieurs variables\net plusieurs types de données en même temps - par exemple des valeurs\ncontinues et des valeurs catégoriques. Les data frames\nsont alors mieux adaptés : il s’agit de tableaux de valeurs ayant une\nstructure en deux dimensions, des lignes et des\ncolonnes, chaque colonne pouvant contenir un type\ndifférent de données.\nNous pourrions par exemple avoir un tableau de données dont une\ncolonne appelée “Envergure” contient des mesures d’envergures chez\ndifférentes espèces d’oiseaux, et une deuxième colonne appelée “Espèce”\ncontient les noms des espèces dont on a mesuré l’envergure.\nLa matrice est un autre format possible de données :\nelle peut également contenir plusieurs lignes, mais toutes les variables\nd’une matrice doivent être du même type et contenir le même nombre\nd’éléments.\nConseil de bonne pratique : conservez toujours\nune copie de vos données brutes ! Votre script R vous permet de\nmanipuler et modifier ces données sans toucher aux données brutes. Si\nvous utilisez des logiciels de retouche photo, c’est un peu la même\nchose que d’ajouter des couches apportant des modifications à votre\ncliché sans modifier la photo d’origine. Ceci dit, si vos données brutes\nnécessitent un long morceau de code pour être analysables, vous pouvez\nsauvegarder une version nettoyée de vos données brutes pour ne pas avoir\nà refaire toutes les étapes de nettoyage des données.\nNous allons utiliser deux nouvelles fonctions :\ndata.frame() pour créer notre data frame et\nwrite.csv() pour le sauvegarder. Nous allons créer les\nobjets “categories” et “comptage”, transformer l’objet “categories” en\nfacteur, puis rassembler ces deux objets dans un data frame.\n\n\n# Creer un objet \"categories\"\ncategories <- c(\"En danger critique\",\n                \"En danger\",\n                \"Vulnerable\",\n                \"Quasi-menacee\",\n                \"Preoccupation mineure\")\n\n# Transformer cet objet en facteur\ncategories_f <- factor(categories)\n\n# Creer un objet \"comptage\"\ncomptage <- c(a, b, c, d, e)\n\n# Creer un data frame avec ces deux vecteurs\nespeces_menacees <- data.frame(categories_f, comptage)\n\n# Sauvegarder le data frame\nwrite.csv(especes_menacees, file = \"especes_menacees.csv\")\n\n\n\nPour créer un barplot à partir de ce data frame, vous devrez modifier\nle code utilisé précédemment - il faut en effet préciser quelle variable\ndu data frame vous souhaitez représenter.\n\n\npng(\"barplot2.png\",\n    width = 1600, height = 600)\n\nbarplot(especes_menacees$comptage,\n        names.arg = c(\"En danger critique\",\n                      \"En danger\",\n                      \"Vulnerable\",\n                      \"Quasi-menacee\",\n                      \"Preoccupation mineure\"),\n        xlab = \"Niveau   de menace\", ylab = \"Nombre d'especes\",\n        ylim = c(0, 70),\n        cex.names = 1.5, cex.axis = 1.5, cex.lab = 1.5)\n\n\n\n\nIl existe une manière plus simple de préciser les étiquettes …\nBilan du tutoriel :\nVous vous êtes familiarisé avec l’interface RStudio\nVous savez comment créer et annoter un fichier de script\nVous pouvez importer vos propres données dans RStudio\nVous savez comment vérifier et explorer vos données\nVous pouvez générer des graphiques basiques et les exporter\nDéfi\nSi c’est votre premier contact avec R, ne vous inquiétez pas si vous\nne comprenez pas tout, tout de suite. Revenez sur les sections que vous\navez trouvées plus difficiles à tête reposée.\nVoici un petit défi pour mettre en pratique ce que vous avez vu dans\nce tutoriel.\nVous verrez ci-dessous des données (fictives) de mesures d’envergure\n(en cm) pour quatre espèces différentes d’oiseaux. Essayez de créer un\nbarplot de l’envergure moyenne pour chacune des espèces et\nsauvegardez-le sur votre ordinateur.\n\nIl vous faudra trouver une fonction permettant de calculer une moyenne\nespece\nenvergure (cm)\nAigle\n195\nChouette\n85\nColibri\n8\nMoineau\n24\nAigle\n201\nChouette\n102\nColibri\n9\nMoineau\n21\nAigle\n185\nChouette\n91\nColibri\n9\nMoineau\n22\nSolution\nNe regardez pas avant d’avoir essayé ! Il n’existe\npas une seule solution possible, plusieurs façons de procéder amèneront\nau même résultat. Les noms des objets et l’apparence du graphique seront\nsans doute différents, et cela ne pose aucun problème - du moment que\nles valeurs elles-mêmes sont correctes.\n\n\nShow code\n\n# Extraire les envergures pour chaque espece\nenv_aigle <- c(195, 201, 185)\nenv_chouette <- c(85, 102, 91)\nenv_colibri <- c(8, 9, 9)\nenv_moineau <- c(24, 21, 22)\n\n# Calculer l'envergure moyenne\nenv_moy_aigle <- mean(env_aigle)\nenv_moy_chouette <- mean(env_chouette)\nenv_moy_colibri <- mean(env_colibri)\nenv_moy_moineau <- mean(env_moineau)\n\n# Rassembler ces valeurs moyennes dans un vecteur\nenv_moyenne <- c(env_moy_aigle, env_moy_chouette, env_moy_colibri, env_moy_moineau)\n\n# Creer un vecteur avec les noms des especes (attention à l'ordre !)\nespeces <- c(\"Aigle\", \"Chouette\", \"Colibri\", \"Moineau\")\n\n# Transformer ce vecteur en un facteur\nespeces_f <- as.factor(especes)\nclass(especes_f)\n\n# Combiner les deux vecteurs dans un data frame\nenvergure <- data.frame(especes_f, env_moyenne)\n\n# Sauvegarder le barplot dans un fichier\npng(\"barplot_envergure.png\",\n    width = 1600, height = 600)\n\nbarplot(envergure$env_moyenne,\n        names.arg = envergure$especes_f,\n        xlab = \"Espèces\", ylab = \"Envergure moyenne\",\n        ylim = c(0, 200),\n        cex.names = 1.5, cex.axis = 1.5, cex.lab = 1.5,\n        col = \"gold\")  # modifier la couleur des barres\n\ndev.off()\n\n\n\nGlossaire\n Voici quelques termes importants vus dans ce tutoriel :\nargument : élément d’une fonction, essentiel ou\noptionnel, qui précise ou modifie la façon dont la fonction est\nexécutée. Par exemple, il peut s’agir du chemin vers un fichier qui sera\nimporté, ou de l’emplacement où sera sauvegardé un fichier :\nfile = \"chemin-vers-le-fichier. Il peut aussi modifier les\ncouleurs d’un graphique : col = \"blue\". Vous pouvez trouver\nune liste des arguments d’une fonction à l’aide de la commande\n?nom-de-la-fonction.\nclasse : le type de données contenu dans une\nvariable : habituellement des charactères (texte/mots), des nombres\nentiers ou relatifs, ou des facteurs (des valeurs de groupement, utiles\nquand vos données contiennent de multiples observations issues de\ndifférents sites ou traitements).\ncommande : un morceau de code qui exécute une\naction, contient généralement une ou plusieurs fonctions. Vous pouvez\nexécuter une commande en cliquant sur “Run” ou grâce aux raccourcis\nclavier comme Cmd + Entrée, Ctrl + Entrée ou\nCtrl + R.\ncommentaire : un morceau de texte dans un script\nqui débute par un hashtag # et qui n’est pas lu comme une\ncommande. Les commentaires rendent le code plus facilement lisible pour\nd’autres personnes : utilisez-les pour créer des sections dans votre\nscript et pour annoter chaque étape de votre analyse.\nconsole : la fenêtre dans laquelle vous pouvez\ntaper du code directement en ligne de commande (2+2 puis\nEntrée retournera 4), et où les résultats des\ncommandes seront affichés.\ndata frame : un type d’objet R composé de\nnombreuses lignes et colonnes (pensez à une feuille Excel). Généralement\nles colonnes contiennent différentes variables (par exemple âge,\ncouleur, poids, envergure), et les lignes les observations de ces\nvariables (par exemple oiseau1, oiseau2, oiseau3).\nespace de travail : c’est votre environnement de\ntravail virtuel, il contient toutes les fonctions des packages que vous\navez chargés, les objets que vous avez créés, et ainsi de suite. Il est\npréférable de démarrer une session de travail avec un espace de travail\nvide.\nfichier csv : un type de fichier couramment\nutilisé pour importer des données dans R, où les valeurs des différentes\nvariables sont compressées (une chaîne, ou une ligne de valeurs par\nligne) et séparées seulement par des virgules (indiquant les colonnes).\nR peut aussi lire des fichiers Excel (.xlsx), mais cela n’est pas\nrecommandé car il est difficile d’éviter les erreurs de\nformatage.\nfonction : du code qui exécute une action,\nc’est-à-dire tout ce que vous faites dans R. Une fonction prend une\nentrée, la modifie d’une façon ou d’une autre, et retourne une sortie\n(un objet, un résultat de test, un fichier, un graphique). Il existe des\nfonctions pour importer, convertir et manipuler des données, pour\neffectuer des calculs spécifiques (essayez de deviner ce que\nretourneraient les fonctions min(10, 15, 5) et\nmax(10, 15, 5)), générer des graphiques, et bien\ndavantage.\nobjet : les briques de construction de R. Si R\nétait un langage parlé, les fonctions seraient les verbes (actions) et\nles objets les noms (les sujets ou les objets de ces actions). On fait\nappel à un objet par son nom sans guillemets. Les objets permettent de\nstocker des données, et prennent différentes formes. Les objets les plus\ncourants sont les data frames et les vecteurs, mais il en existe\nd’autres, comme les listes et les matrices.\npackage : un ensemble de fonctions qui apportent\ndes fonctionnalités supplémentaires à R. De nombreux packages sont\ninclus dans R, d’autres peuvent être téléchargés pour des besoins\nspécifiques.\nrépertoire de travail : le dossier sur votre\nordinateur associé à votre session R actuelle, contenant les données que\nvous allez importer et où vous sauvegarderez des fichiers. Vous pouvez\nle définir au début de votre session à l’aide de la fonction\nsetwd().\nscript : comme un éditeur de texte, un script\nvous permet d’écrire votre code et de le sauvegarder pour des usages\nfuturs. Il contient un mélange de code et de commentaires et est\nsauvegardé comme un simple fichier texte que vous pouvez aisément\npartager pour que n’importe qui puisse reproduire votre\ntravail.\nvecteur : un type d’objet R qui ne contient\nqu’une seule dimension : il stocke une ligne de valeurs qui peuvent être\ndes caractères, des nombres, etc.\n\n\n\n\n",
    "preview": "posts/premiers-pas-avec-r/img/happy-r.png",
    "last_modified": "2022-05-03T10:01:55+02:00",
    "input_file": {}
  }
]
