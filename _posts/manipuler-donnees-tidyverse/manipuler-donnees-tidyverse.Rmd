---
title: "Manipulation de données"
description: |
  Manipuler et mettre en forme vos données à l'aide du Tidyverse.
author:
  - name: Sandra Angers-Blondin
    url: https://ourcodingclub.github.io/tutorials/data-manip-intro
  - name: Jonathan Kitt (adaptation)
    url: {}
date: 2022-05-20
categories:
  - R
  - RStudio
  - Données
  - Tidyverse
output:
  distill::distill_article:
    toc: true
    toc_depth: 1
    self_contained: false
draft: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

*Ce tutoriel est adapté de [Basic data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-intro/index.html) et [Efficient data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-efficient/) du site [Our Coding Club](https://ourcodingclub.github.io/).* 

# Introduction

```{r, layout="l-body-outset"}
knitr::include_graphics("img/data_cowboy.png")
```
Dessin de [Allison Horst](https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/rstats-artwork/data_cowboy.png)

<br>

Les formats de nos données peuvent varier, et un format utile et pratique dans un cas précis ne le sera pas forcément dans un autre. La maîtrise des outils de manipulation et de mise en forme des données est donc essentielle !

<br>

Les **objectifs** de ce tutoriel sont les suivants :  

1. Utiliser les outils du package `dplyr` pour manipuler des données  
2. Mettre en forme des données à l'aide du package `tidyr`

<br>

Voici les **étapes** que nous allons suivre pour y parvenir :  
<br>

1. [Explorer les principales fonctions de `dplyr`](#dplyr) : [`rename()`](#rename), [`filter()`](#filter), [`select()`](#select), [`arrange()`](#arrange), [`mutate()`](#mutate), [`group_by()`](#groupby), [`summarise()`](#summarise), [`join()`](#join)  

2. [Mettre en forme des données à l'aide du package `tidyr`](#tidyr) : [`pivot_longer()`](#pivotlonger), [`pivot_wider()`](#pivotwider)   

3. [Défi](#defi)

<br>

Vous pouvez revoir les bases de R et RStudio dans le tutoriel [Premiers pas avec R](https://codons.netlify.app/posts/premiers-pas-avec-r/).

<br>

## Le Tidyverse

Le [**Tidyverse**](https://www.tidyverse.org/) est un ensemble de packages permettant notamment d'**importer des données (`readr`)**, de les **manipuler (`dplyr` et `tidyr`)**, de créer des **graphiques (`ggplot2`)**, de **manipuler des chaînes de caractères (`stringr`)**, de **créer des documents (`rmarkdown`)**, ...

```{r, layout="l-body-outset"}
knitr::include_graphics("img/tidyverse_celestial.png")
```
Dessin de [Allison Horst](https://github.com/allisonhorst/stats-illustrations/blob/master/rstats-artwork/tidyverse_celestial.png)

<br>

Commençons par **installer la suite Tidyverse** (nous pourrions également installer séparément les packages que nous allons utiliser, `dplyr` et `tidyr`) : 

```{r, echo=TRUE, eval=FALSE}
# Installer le Tidyverse
install.packages("tidyverse")
```

# Manipuler des données avec `dplyr` {#dplyr}

Les fonctions du package [`dplyr`](https://dplyr.tidyverse.org/) sont **nommées d'après l'action qu'elles accomplissent**, ce qui les rend plutôt intuitives.

Nous allons utiliser un jeu de données contenant des mesures de croissance annuelle de tiges d'arbrisseaux qui poussent dans des dunes de sable ([*Empetrum nigrum*](https://fr.wikipedia.org/wiki/Empetrum_nigrum) ou camarine noire). La distance à la mer de chaque individu est codée dans la variable catégorique "zone" : le chiffre 2 représente la zone la plus proche de la mer et le chiffre 7 la zone la plus éloignée de la mer.

```{r, out.width="100%"}
knitr::include_graphics("img/empetrum.jpg")
```

Nous allons importer les données à l'aide du package [`readr`](https://readr.tidyverse.org/) inclus dans le Tidyverse : `read_csv()`. Cette fonction permet d'importer un fichier .csv directement depuis une page web en utilisant le lien de la page à la place du chemin vers un fichier présent sur notre ordinateur.

```{r, echo=TRUE, eval=FALSE}
# Ateliers codons!
# 02 - Manipulation de donnees
# Lundi 30/05/2022

# Charger le Tidyverse

library(tidyverse)

# Definir le repertoire de travail

setwd("C-02-ManipulationDonnees")

# Importer le jeu de donnees

croissance <- read_csv("https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonneesBases/main/croissance.csv")

# Exploration rapide des donnees

head(croissance)  # affiche les premieres lignes
str(croissance)  # types des variables
unique(croissance$Zone)  # affiche les valeurs distinctes de la variable Zone
croissance$Indiv  # affiche toutes les valeurs de la variable Indiv
length(unique(croissance$Indiv))  # affiche le nombre d'individus
```

Lorsque vous exécutez la commande `head(croissance)`, vous pouvez remarquer dans la console la mention "A tibble". Un [**tibble**](https://tibble.tidyverse.org/index.html) est un format particulier de tableau utilisé par le Tidyverse. Il présente notamment l'avantage d'afficher directement sous les noms de colonnes les types de variables. 

## Renommer des variables avec `rename()` {#rename}

Cette fonction s'utilise de la façon suivante : `rename(objet, nouveau_nom = ancien_nom)`.

```{r, echo=TRUE, eval=FALSE}
# Supprimer les majuscules dans les noms de colonnes
croissance <- rename(croissance,
                      zone = Zone,
                      indiv = Indiv)
```

<br>
Avant d'aller plus loin, nous allons voir une fonctionnalité extrêmement pratique : **le "pipe"**. Un pipe permet d'enchaîner les opérations, et présente plusieurs avantages, notamment de rendre le **code plus clair et lisible** et de rendre possible l'**auto-complétion** (à l'aide de la touche `Tab`).  

Le pipe fait partie du package [`magrittr`](https://magrittr.tidyverse.org/), inclus dans le Tidyverse.  

Un pipe se place à la fin d'un ligne sous la forme `%>%`, ce qui donne, si nous reprenons la dernière commande exécutée : 

<aside>
Raccourci clavier : `Ctrl + Shift + M`
</aside>

```{r, echo=TRUE, eval=FALSE}
# Utilisation du pipe
croissance2 <- croissance %>% 
  rename(zone = Zone,
         indiv = Indiv)
```

## Sélectionner des colonnes avec `select()` {#select}

Cette fonction permet de sélectionner des colonnes, en précisant lesquelles conserver ou supprimer : 

```{r, echo=TRUE, eval=FALSE}
# Conserver des colonnes

croissance2_selection <- croissance2 %>% 
  select(indiv, `2007`:`2012`)

# Supprimer une colonne

croissance2_selection <- croissance2 %>% 
  select(-zone)

```

Dans les exemples ci-dessus, nous ne montrons qu'une seule fonction à la fois. Nous pourrions également enchaîner les fonctions : 

```{r, echo=TRUE, eval=FALSE}
# Enchainer les fonctions

croissance2_selection <- croissance %>% 
  rename(zone = Zone, indiv = Indiv) %>% 
  select(indiv, `2007`:`2012`)

```

La fonction `select()` permet également de renommer des colonnes et d'en modifier l'ordre : 

```{r, echo=TRUE, eval=FALSE}
# Renommer et modifier l'ordre de colonnes

croissance2_selection <- croissance %>% 
  select(zone = Zone, indiv = Indiv, `2007`:`2012`)
```

L'opérateur `:` permet de construire une **séquence** : dans le cas présent il permet de sélectionner toutes les colonnes entre 2007 et 2012.  

Si vous souhaitez renommer ou déplacer seulement quelques colonnes, vous pouvez utiliser la fonction `everything()` pour sélecionner toutes les colonnes restantes : 

```{r, echo=TRUE, eval=FALSE}
croissance2_selection <- croissance %>% 
  select(zone = Zone, indiv = Indiv, everything())
```

## Filtrer des données avec `filter()` {#filter}

Cette fonction permet de sélectionner des lignes à l'aide d'opérateurs logiques, dont les plus courants sont les suivants : 

Opérateur   Expression logique
----------  -------------------
==          strictement égal à
<=          inférieur ou égal à
<           inférieur à
>=          supérieur ou égal à
>           supérieur à
!=          différent de
%in%        appartient à
&           ET
|           OU
!           PAS  

Voyons comment utiliser ces opérateurs logiques : 

```{r, echo=TRUE, eval=FALSE}
# Selectionner l'individu n°603

croissance2 %>% filter(indiv == 603)

# Selectionner les zones 2, 3 et 4

croissance2 %>% filter(zone <= 4)
croissance2 %>% filter(!zone >= 5)

# Selectionner les zones 2 et 7

croissance2 %>% filter(zone == 2 | zone == 7)
croissance2 %>% filter(zone %in% c(2, 7))

# Selectionner les individus dans la zone 2 avec des identifiants entre 300 et 400
croissance2 %>% filter(zone == 2, indiv %in% 300:400)
croissance2 %>% filter(zone == 2, between(indiv, 300, 400))
```

La commande, `indiv %in% 300:400` permet de sélectionner les individus ayant des identifiants entre 300 et 400. Il existe différentes façons de construire ce genre de séquence : 

```{r, echo=TRUE, eval=FALSE}
# Sequence par increments

seq(300, 400, 10)  # de 300 a 400 avec un increment de 10

# Repetition d'elements

rep(c(1, 2, 3), 3)  # "1 2 3" repete 3 fois

# Combinaison des deux

rep(seq(0, 30, 10), 4)

```

## Trier des données avec `arrange()` {#arrange}

La fonction `arrange()` permet de trier des valeurs par ordre croissant ou décroissant : 

```{r, echo=TRUE, eval=FALSE}
# Trier par ordre croissant sur l'annee 2007

croissance2 %>% arrange(`2007`)

# Trier par ordre decroissant sur l'annee 2008

croissance2 %>% arrange(desc(`2008`))
```

## Créer de nouvelles colonnes avec `mutate()` {#mutate}

La fonction `mutate()` permet de créer un nouvelle colonne, par exemple pour effectuer une opération impliquant plusieurs colonnes :

```{r, echo=TRUE, eval=FALSE}
# Calculer la croissance totale pour chaque individu entre 2007 et 2012
croissance2_totale <- mutate(croissance2,
                            croissance.totale = X2007 + X2008 + X2009 + X2010 + X2011 + X2012)

```

#### Définir des groupes avec `group_by()` {#groupby}

La fonction `group_by()` permet de définir des groupes dans nos données : 

```{r, echo=TRUE, eval=FALSE}
# Grouper par zone

croissance2_groupes <- group_by(croissance2, zone)
```

Si vous comparez les deux objets `croissance2` et `croissance2_groupes`, vous ne verrez aucune différence, si ce n'est la mention `Groups` quand vous affichez l'objet `croissance2_groupes`. Les groupes créés sont sous-jacents, jusqu'à ce qu'on applique une autre fonction à ces groupes. 

#### Agréger des lignes avec `summarise()` {#summarise}

La fonction `summarise()` permet d'agréger des lignes en appliquant une fonction sur une ou plusieurs colonnes :

```{r, echo=TRUE, eval=FALSE}
# Croissance totale pour l'ensemble des individus pour l'annee 2007

synthese1 <- summarise(croissance2, croisance.2007 = sum(X2007))

# Croissance totale pour l'ensemble des individus groupes par zone pour l'annee 2007
synthese2 <- summarise(croissance2_groupes, croissance.2007 = sum(X2007))
```

Les données étant agrégées, le tableau de sortie sera plus court que les données d'origine.

Vous pouvez utiliser cette fonction pour calculer différentes statistiques sur vos données : 

```{r, echo=TRUE, eval=FALSE}
synthese3 <- summarise(croissance2_groupes,
                       croissance.totale.2007 = sum(X2007),
                       croissance.moyenne.2007 = mean(X2007),
                       croissance.ecart.type.2007 = sd(X2007))
```

#### Joindre des données avec `..._join()` {#join}

Il peut arriver que des données concernant un même projet se trouvent dans plusieurs fichiers (par exemple un fichier avec des mesures sur différents sites, et un autre fichier avec des données climatiques pour ces différents sites).
Les fonctions `..._join()` permettent de joindre plusieurs jeux de données.

Le fichier `traitements.csv` contient des informations sur des traitements appliqués aux plantes : températe (T), fertilisation (F), température + fertilisation (TF), ou contrôle (C).

```{r, echo=TRUE, eval=FALSE}
# Importer le jeu de données (attention : utilisation de read.csv2)
traitements <- read.csv2("https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/traitements.csv")
```

Il existe différents manières de joindre des données, selon ce qu'on souhaite faire des données qui ne sont pas partagées par les jeux de données. Nous allons utiliser la fonction `left_join()` pour garder toutes les données présentes dans `croissance2` et y ajouter les données présentes dans `traitements` : 

```{r, echo=TRUE, eval=FALSE}
# Joindre deux jeux de données

expe <- left_join(croissance2, traitements,
                  by = c("zone" = "Zone",
                         "indiv" = "Indiv"))

```

Les noms des deux colonnes communes aux deux jeux de données diffèrent, nous précisons donc les équivalences dans l'argument `by()`. Si les noms avaient été strictement identiques, nous aurions pu nous passer de cet argument.

Nous pouvons générer un boxplot pour vérifier si les traitements ont eu un effet sur la croissance de nos plantes en 2012 : 

```{r, echo=TRUE, eval=FALSE}
# Effet des traitements sur la croissance en 2012

boxplot(X2012 ~ Traitement, data = expe,
        main = "Effet de la température (T) et de la fertilisation (F)\nsur la croissance",
        ylab = "Croissance totale en 2012")

```

Le code `\n` dans l'argument `main` permet de répartir le titre du graphique sur deux lignes.

```{r, layout="l-body-outset"}
knitr::include_graphics("img/boxplot.png")
```

# Mettre en forme des données à l'aide de `tidyr` {#tidyr}

La façon dont nous récoltons des données sur le terrain ou au laboratoire peut être très différente du format que nous aimerions utiliser dans R. Lors d'une expérimentation, nous préférons utiliser des tableaux préparés à l'avance, à remplir au fur et à mesure. Par exemple, pour suivre la hauteur de semis soumis à différents traitements, nous pourrions utiliser un tableau similaire à celui-ci :  

```{r, layout="l-body-outset"}
knitr::include_graphics("img/tidy_data_1.png")
```

Ce tableau, pratique à remplir, n'est pas idéal pour une analyse (8 mesures par ligne). 

Il est préférable d'utiliser des données au format dit **"tidy"** :  

- chaque ligne représente une observation  
- chaque colonne contient une variable  

Dans le cas présent, les mêmes données au format tidy ressembleraient à ceci : 

```{r, layout="l-body-outset"}
knitr::include_graphics("img/tidy_data_2.png")
```

Ce format facilite les analyses en permettant les comparaisons entre groupes, traitements, espèces, ...

Le jeu de données que nous avons utilisé dans ce tutoriel, `croissance` n'est pas dans un format tidy : la même variable, la mesure de croissance, est répartie sur plusieurs colonnes représentant les années.

Le package `tidyr` permet de jongler entre un format large et un format long, grâce aux fonctions `pivot_...()`.

Commençons par installer et charger le package : 

```{r, echo=TRUE, eval=FALSE}
# Installer le package tidyr

install.packages("tidyr")

# Charger le package

library(tidyr)
```

## Format long avec `pivot_longer()`

La fonction `pivot_longer()` permet de passer d'un format large à un format long. La syntaxe est un peu plus complexe que les fonctions que nous avons vues jusqu'à présent, car il nous préciser quelles colonnes vont être regroupées : 

```{r, echo=TRUE, eval=FALSE}
# Format large -> format long

croissance_long <- pivot_longer(croissance,  # objet a transformer
                                cols = c(X2007:X2012),  # colonnes a regrouper
                                names_to = "Annee",  # nom de la colonne contenant les noms des colonnes regroupees
                                values_to = "Croissance")  # nom de la colonne contenant les valeurs
```

Ce format long permet de visualiser facilement la croissance annuelle en fonction de l'annee : 

```{r, echo=TRUE, eval=FALSE}
# Boxplot de la croissance par annee

boxplot(Croissance ~ Annee,
        data = croissance_long,
        main = "Croissance annuelle",
        ylab = "Croissance (cm)")

```

```{r, layout="l-body-outset"}
knitr::include_graphics("img/boxplot2.png")
```

## Format large avec `pivot_wider()`

<iframe width="560" height="315" src="https://www.youtube.com/watch?v=ylaCmXw0fBQ" frameborder="0" allowfullscreen></iframe>



La fonction `pivot_wider()` effectue l'opération inverse : 

```{r, echo=TRUE, eval=FALSE}
# Format long -> format large

croissance_large <- pivot_wider(croissance_long,
                                names_from = Annee,  
                                values_from = Croissance)
```

# Défi {#defi}

Mettons en pratique ce que nous avons vu dans ce tutoriel pour tenter de répondre à la question suivante : quelle est l'effet de différentes épices sur la taille des flammes crachées par trois espèces de dragons ?

Commençons par importer les données : 

```{r, echo=TRUE, eval=FALSE}
dragons <- read.csv("https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv")
```

Voici les objectifs : 

- mettre en forme les données (format tidy)  
- créer un boxplot pour chaque espèce montrant l'effet des épices sur la taille des flammes

Malheureusement, vous apprenez que votre assistant a été peu scrupuleux lors de la collecte des données, et il vous faut corriger les erreurs suivantes : 

- la quatrième épice n'était pas du paprika, mais du curcuma  
- l'appareil de mesure était mal calibré lors du traitement au tabasco, mais seulement pour les Magyar à pointes : les mesures sont plus longues de 30 cm que la réalité  
- les tailles sont données en centimètres, alors qu'elles devraient être en mètres.

```{r, echo=TRUE, eval=FALSE, collapse=TRUE}
# Importer les données

dragons <- read.csv("https://raw.githubusercontent.com/codons-blog/C-02-ManipulationDonnees/main/dragons.csv")
```


