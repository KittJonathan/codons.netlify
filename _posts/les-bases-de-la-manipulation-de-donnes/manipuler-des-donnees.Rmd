---
title: "Les bases de la manipulation de données"
description: |
  Sélectrionner, modifier et mettre en forme vos données.
author:
  - name: Sandra Angers-Blondin
    url: https://ourcodingclub.github.io/tutorials/data-manip-intro
  - name: Jonathan Kitt (adaptation)
    url: {}
date: 2022-05-02
categories:
  - R
  - RStudio
  - Données
  - Tidyverse
output:
  distill::distill_article:
    toc: true
    toc_depth: 1
    self_contained: false
draft:
  true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Les données **tidy** {#tidy}

Quand vous mesurez des données dans les champs ou au laboratoire, vous souhaitez avoir des tableaux préparés à l'avance à remplir au fur et à mesure. Par exemple, si vous mesurez la hauteur de semis au cours d'une expérimentation visant à mesurer les effets de la température et de la fertilisation, vous pourriez utiliser le tableau suivant :

```{r, layout="l-body-outset"}
knitr::include_graphics("img/tidy_data_1.png")
```

Si vous savez comment votre expérimentation a été menée, R n'en sait rien ! Dans l'état actuel, avec 8 mesures par ligne, vous ne pouvez pas analyser les données. Les *données tidy** sont arrangées de telle sorte que **chaque ligne représente une observation** et **chaque colonne représente une variable**. Dans notre cas, voici à quoi ressemblerait des données **tidy** :

```{r, layout="l-body-outset"}
knitr::include_graphics("img/tidy_data_2.png")
```

Ce format de tableau comporte plus de lignes, raison pour laquelle on parle de *format long* (le premier tableau ci-dessus est au *format large*). Si vous souhaitez comparer des groupes, des traitements, des espèces, etc., R pourra ainsi séparer les données correctement, chaque facteur de groupement ayant sa propre colonne.
Notre objet `croissance` n'est pas au format **tidy** : les observations d'une même variable, la croissance de la tige, est répartie sur plusieurs colonnes, avec une colonne par année.

<br>
La fonction `pivot_longer()` du package `tidyr` permet de convertir un tableau d'un format large en un format long. Nous allons pour cela créer une colonne `Annee` qui contiendra les valeurs des années (2007 à 2012) répétées pour chaque individu. Le tableau ainsi obtenu aura donc six fois plus de lignes que le tableau d'origine. Nous allons également créer une colonne `Croissance` qui contiendra les données associées à la croissance pour chaque année et chaque individu.

Commençons par installer et charger le package `tidyr`
```{r, eval=FALSE, echo=TRUE}
install.packages("tidyr")
library(tidyr)
```

```{r, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
library(tidyr)
```

```{r, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
croissance_long <- pivot_longer(
  data = croissance,  # objet a transformer
  cols = c(X2007, X2008, X2009, X2010, X2011, X2012),  # colonnes a regrouper
  names_to = "Annee",  # les annees sont regroupees dans cette colonne
  values_to = "Croissance")  # les valeurs mesurees sont regroupees dans cette colonne
```

La fonction `pivot_wider()` permet d'effectuer l'opération inverse : 

```{r, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
croissance_large <- pivot_wider(
  data = croissance_long,  # objet a transformer
  id_cols = c(Zone, Indiv),  # colonnes contenant les identifiants
  names_from = Annee,  # cette colonne sert a creer les noms de colonnes
  values_from = Croissance)  # cette colonne sert a remplir les colonnes
```

Nous avons utilisé les noms des colonnes pour indiquer à `pivot_longer()` quelles colonnes transformer. Cela est pratique si votre jeu de données ne comporte que quelques colonnes. Si votre jeu de données comporte un grand nombre de colonnes (par exemple 100 gènes), il est préférable de spécifier les colonnes par leurs positions : 

```{r, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
croissance_long2 <- pivot_longer(
  data = croissance,
  cols = c(3:8),
  names_to = "Annee",
  values_to = "Croissance")
```

Ces fonctions ont cependant des limites et ne fonctionnent pas avec toutes les structures de données. Pour citer [Hadley Wickham](https://www.jstatsoft.org/article/view/v059i10) (directeur scientifique pour RStudio et l'un des créateurs du tidyverse) : *"chaque jeu de données désordonné est désordonné à sa façon"*. Réfléchir en amont à la structure de vos données peut vous éviter beaucoup de frustrations par la suite !

Une fois que vos données sont au bon format, leur analyse et la visualisation des résultats sera plus simple. Par exemple, si nous souhaitons savoir s'il y a une variation inter-annuelle dans la croissance de **Empetrum hermaphroditum**, nous pouvons rapidement créer un boxplot : 

```{r, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
boxplot(Croissance ~ Annee, data = croissance_long,
        ylab = "Croissance (cm)",
        main = "Croissance annuelle de Empetrum hermaphroditum")
```

Le graphique montre un chevauchement assez important entre les valeurs de croissance par année - pas grand chose à signaler de ce point de vue-là !

# Les fonctions principales de `dplyr` {#dplyr}


## Renommer des variables avec `rename()` {#rename}

Cette fonction vous permet de changer les noms d'une ou de plusieurs colonnes. Le premier argument est le data frame, les arguments suivants prennent la forme *Nouveau nom = Ancien nom* :

```{r, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
# Supprimer les majuscules dans les noms de colonnes et ecraser le data frame
croissance_long <- rename(croissance_long,
                          zone = Zone,
                          indiv = Indiv,
                          annee = Annee,
                          croissance = Croissance)

```

## Filter des lignes avec `filter()` et sélectionner des colonnes avec `select()` {#filter}

Ces deux fonctions vous permettent de réduire votre data frame en ne gardant que les lignes et les colonnes souhaitées. La fonction `filter()` fonctionne très bien pour sélectionner des lignes à l'aide d'opérations logiques, et la fonction `select()` vous permet de spécifier quelles colonnes garder.  
*La fonction `select()` entre souvent en conflit avec des fonctions d'autres packages portant le même nom, il est donc recommandé de toujours utiliser la notation `dplyr::select()`.

```{r, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
# Conserver les observations pour les zones 2 et 3, et pour les années 2009 à 2011
croissance_selection <- filter(croissance_long, zone %in% c(2, 3), annee %in% c("X2009", "X2010", "X2011"))

# A titre de comparaison, l'equivalent en R basique serait :
croissance_long[croissance_long$zone %in% c(2, 3) & croissance_long$annee %in% c("X2009", "X2010", "X2011"), ]
```

Notez qu'ici, nous utilisons `%in%` comme opérateur logique parce que nous cherchons une liste de valeurs exactes (caractères). Si vous vouliez garder les observations dans une gamme de valeurs *numériques*, vous pourriez utiliser soit deux opérateurs logiques dans votre fonction `filter()`, par exemple `longueur > 4 & longueur <= 6.5` soit la fonction `between()`, par exemple `between(longueur, 4, 6.5)`. 

Vous voyez comment `dplyr` permet d'éviter des répétitions et d'appeler directement les noms de colonnes sans avoir besoin d'appeler à chaque fois l'objet ?

### A propos des guillemets

Vous avez peut-être remarqué que nous utilisons parfois des guillemets `" "` pour appeler des valeurs, et que d'autres fois nous ne les utilisons pas. Cela dépend de :

- *Si la valeur est un caractère ou un nombre* : ci-dessus, `zone` est un entier, nous n'avons donc pas besoin de guillemets, alors que la variable `annee` est un caractère, et nécessite donc des guillemets.  
- *Si vous faites appel à un objet existant ou à une valeur que R ne connaît pas encore*. Par exemple, `nouvel.objet <- croissance_long` duplique notre objet alors que `nouvel.objet <- "croissance_long"` crée un nouvel objet contenant une chaîne de caractères.
Cela demande du temps et de la pratique pour s'habituer à ces conventions, mais vous y arriverez en gardant un oeil sur les messages d'erreur.

Maintenant que nous savons sélectionner des lignes, faisons la même chose avec les colonnes !

```{r, eval=FALSE, echo=TRUE}
# Retirons la colonne zone
croissance_sans_zone <- dplyr::select(croissance_long, indiv, annee, croissance)
croissance_sans_zone <- dplyr::select(-zone)  # le signe moins retire la colonne

# Equivalent en R basique 
croissance_long[, -1]  # retire la premiere colonne

# select() vous permet de renommer et d'ordonner les colonnes
croissance_sans_zone <- dplyr::select(croissance_long, Annee = annee, ID.Arbrisseau = indiv,
                                      Croissance = croissance)
```

## Créer de nouvelles colonnes avec `mutate()`

Créer une nouvelle colonne peut être pratique pour réaliser une opération sur plusieurs colonnes, ou pour changer le classement d'un facteur. La fonction `mutate()` vous permet de faire cela, et vous permet également de définir le nom de la colonne. Nous utilisons ici l'objet `croissance_long` pour créer une colonne représentant la croissance totale pour la période 2007-2012 : 

```{r, eval=FALSE, echo=TRUE}
croissance_totale <- mutate(croissance, croissance.totale = X2007 + X2008 + X2009 + X2010, X2011, X2012)
```

Nous allons maintenant voir comment faire la même chose avec notre objet `croissance_long` à l'aide de deux fonctions qui vont bien ensemble : `group_by()` et `summarise()`.

## Effectuer des opérations sur des portions de données à l'aide de `group_by()`

La chose la plus important à comprendre avec cette fonction est que nous ne voyez pas de changement visible dans votre data frame. Elle crée une structure de groupement interne, ce qui veut dire que toutes les fonctions exécutées par la suite utiliseront ces groupes, et pas le jeu de données en entier, comme entrée. Cette fonction est très utile pour calculer des statistiques pour différents sites, traitements, espèces, etc.

```{r, eval=FALSE, echo=TRUE}
croissance_groupes <- group_by(croissance_long, indiv)  # nous regroupons nos données par individu
```

Comparez `croissance_groupes` et `croissance_long` : les deux objets semblent parfaitement identiques. Utilisons maintenant `summarise()` pour calculer la croissance totale de chaque individu au cours des années.

## Calculer des statistiques avec `summarise()`

Cette fonction aggrègera toujours votre data frame d'origine, c'est-à-dire que le data frame résultant sera plus court que l'original. Ici, nous allons comparer le calcul de la croissance totale sur la même période pour les données d'origine et pour les données **groupées**.

```{r, eval=FALSE, echo=TRUE}
synthese1 <- summarise(croissance_long, croissance.totale = sum(croissance))
synthese2 <- summarise(croissance_groupes, croissance.totale = sum(croissance))
```

Le premier objet, `synthese1`, contient la somme de toutes les croissances dans le jeu de données (tous les individus et toutes les annees).  
L'objet `synthese2` contient la somme des croissance **par individu**, notre variable de groupement. Nous pouvons calculer toutes sortes de statistiques, comme la moyenne ou l'écart-type de la croissance au cours du temps : 

```{r, eval=FALSE, echo=TRUE}
synthese3 <- summarise(croissance_groupes, 
                       croissance.totale = sum(croissance),
                       moyenne.croissance = mean(croissance),
                       ecart.type.croissance = sd(croissance))
```

Nous perdons toutes les autres colonnes non spécifiées dans l'étape de groupement. Par exemple, nous avons perdu la colonne `annee` car il y a 5 années pour chaque individu, et nous synthétisons les données pour obtenir une seule valeur de croissance par individu. Il est donc préférable de créer un nouvel objet pour la synthèse de données, pour ne pas perdre le jeu de données global. Vous pourrez toujours joindre des informations ultérieurement, comme nous allons le voir maintenant.

## Joindre des jeux de données avec `..._join()`

Parfois, vous avez de multiples fichiers de données pour un même projet : un fichier pour des mesures sur différents sites, un autre fichier avec des données climatiques pour ces sites, et parfois des métadonnées concernant votre expérimentation. En fonction des besoins de votre analyse, il peut être utile de regrouper toutes ces informations dans un seul tableau.

Imaginons que les données avec lesquelles nous travaillons viennent d'une expérimentation lors de laquelle certaines plantes ont reçu un traitement à la chaleur à l'aide d'une serre portable (T), d'autres plantes ont été fertilisées (F), certaines ont reçu les deux traitements (TF) et des plantes ont servi de contrôle (C). Nous importons ces données contenues dans le fichier `traitements.csv` et joignons ce tableau avec notre jeu de données principal `croissance_long`. Nous pouvons le faire car les deux jeux de données ont une colonne représentant l'identifiant de chaque plante.

Il existe différentes façons de joindre des jeux de données (ce qui vous semblera familier si vous utilisez le langage SQL), qui diffèrent par la façon de traiter les données qui ne sont pas partager par les deux tableaux, demandez-vous donc toujours quelles observations vous souhaitez conserver et quelles observations vous souhaitez supprimer, et consultez les documentations des fonctions si nécessaire (dans le doute, `full_join()` conservera toutes les observations). Dans l'exemple suivant, nous souhaitons conserver toutes les informations de `croissance_long` et répéter le code du traitement appliqué pour les cinq répétitions de chaque individu, nous utilisons donc `left_join`.

```{r, eval=FALSE, echo=TRUE}
traitements <- read.csv2("traitements.csv")  # importer le fichier
head(traitements)  # afficher les 6 premieres lignes

# Deux colonnes sont communes aux deux jeux de donnees, mais avec des noms differents.
# L'argument "by" permet de préciser les noms propres aux deux tableaux.

expe <- left_join(croissance_long, traitements,
                  by = c("indiv" = "Indiv", "zone" = "Zone"))
```

Notre nouvel objet `expe` contient le même nombre de lignes que l'objet d'origine `croissance_long`, c'est ce que nous souhaitions. Ce nouvel objet contient bien les informations concernant les traitements appliques a chaque individu.

Si les colonnes communes ont exactement le même nom, l'argument `by = ...` n'est pas necessaire car ces colonnes seront automatiquement détectées. Il est cependant recommandé de spécifier les colonnes communes.

La fonction `merge()` permet d'effectuer la même chose en R basique : 

```{r, eval=FALSE, echo=TRUE}
expe2 <- merge(croissance_long, traitements,
               by.x = c("zone", "indiv"),
               by.y = c("Zone", "Indiv"))
```

Nous pouvons maintenant prendre en compte les traitements et générer un nouveau boxplot : 

```{r, eval=FALSE, echo=TRUE}
boxplot(croissance ~ Treatment,
        data = expe)
```

## Bilan  du tutoriel :

1. Vous savez utiliser les opérateurs `$` et `[]` pour sélectionner des éléments
2. Vous comprenez le format **tidy** et savez comment utiliser le package `tidyr` pour transformer vos données
3. Vous pouvez manipuler, filtrer, sélectionner, créer et joindre des données avec le package `dplyr`

# Défi