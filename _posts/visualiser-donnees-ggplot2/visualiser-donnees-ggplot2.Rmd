---
title: "Visualisation de données"
description: |
  Créer des graphiques avec ggplot2.
author:
  - name: Jonathan Kitt
date: 2022-06-30
categories:
  - R
  - RStudio
  - Graphiques
  - ggpplot2
  - Tidyverse
output:
  distill::distill_article:
    toc: true
    toc_depth: 1
    self_contained: false
draft: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Introduction

```{r, layout="l-body"}
knitr::include_graphics("img/ggplot2_blank.png")
```
Dessin de [Allison Horst](https://github.com/allisonhorst/stats-illustrations/blob/master/rstats-blanks/ggplot2_blank.png)

<br>

Nous avons vu comment [importer nos données dans RStudio](https://codons.netlify.app/posts/premiers-pas-avec-r/), et comment [les manipuler et les mettre en forme](https://codons.netlify.app/posts/manipuler-donnees-tidyverse/).  

<br>

Dans ce tutoriel nous allons voir comment communiquer les résultats de nos analyses - à l'aide de la **visualisation de données** :

<br>

**1. [Construire un graphique `ggplot2`](#construction)**  

**2. [Graphiques simples](#creer)** :  

- [`geom_point()`](#scatterplot) 

- [`geom_histogram()`](#histogram)  
  
- [`geom_boxplot()`](#boxplot)  
  
- [`geom_bar()`](#barplot)  

**3. [Graphiques multiples](#facet)**

- [`facet_wrap()`](#facet_wrap)

- [`facet_grid()`](#facet_grid)

**4. [Exporter un graphique](#exporter)**

- [Depuis l'onglet *Plots*](#onglet_plots)  

- [Avec `ggsave()`](#ggsave)

**5. [Améliorer ses graphiques](#ameliorer)**

- [Les différents éléments de `theme()`](#theme)

- [Modifier la police de caractères avec `showtext`](#fonts)

**6. [Combiner des graphiques avec `patchwork`](#patchwork)**

<br> 

# Construire un graphique `ggplot2` {#construire}

<br>

Le package `ggplot2` (qui fait partie de la suite Tidyverse) repose sur le principe de **grammaire des graphiques** : notre visualisation se construit étape par étape, en procédant par **couches**, comme le montre la figure ci-dessous.

```{r, layout="l-body"}
knitr::include_graphics("img/ggplot-grammar-of-graphics.png")
```
Figure tirée de [ggplot2 et la grammaire des graphiques](https://larmarange.github.io/analyse-R/ggplot2.html)

<br>

Toutes ces couches ne sont pas nécessaires à la construction d'un graphique.  
La figure ci-dessous montre de manière simplifiée comment créer un `ggplot` basique : 

**1) `ggplot()`** : initialisation de l'outil graphique  

**2) `aes()`** : paramètres esthétiques (répartition des variables sur les axes, couleurs, ...)  

**3) `geom()`** : type de représentation (points, lignes, ...)  

**4) `theme()`** : apparence du graphique (arrière-plan, taille et alignement du texte, ...)

```{r, layout="l-page"}
knitr::include_graphics("img/ggplot_01.gif")
```

Vous remarquerez dans le code la présence du signe **"+"** à la fin de chaque ligne : c'est ce qui permet d'ajouter une couche à votre graphique.

# Graphiques simples {#creer}

<br>

Commençons par ouvrir un **nouveau script R** et **importer le jeu de données** :

```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)

pingouins <- readr::read_csv("https://raw.githubusercontent.com/codons-blog/C-04-VisualisationDonnees/main/pingouins.csv")
```

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Ateliers codons!
# 04 - Visualisation de donnees avec ggplot2
# 2022-06-30

# Definir le repertoire de travail ----

setwd("codons/C-04-VisualisationDonnees")

# Charger le Tidyverse ----

library(tidyverse)

# Importer le jeu de donnees ----

pingouins <- readr::read_csv("https://raw.githubusercontent.com/codons-blog/C-04-VisualisationDonnees/main/pingouins.csv")
```

<br>

Il est toujours utile de **vérifier les données** importées avant d'aller plus loin :

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
glimpse(pingouins)
```

<br>

Il s'agit du jeu de données [Palmer penguins](https://allisonhorst.github.io/palmerpenguins/), disponible dans le package R [palmerpenguins](https://cloud.r-project.org/web/packages/palmerpenguins/index.html).  

Différents paramètres ont été mesurés sur trois espèces de pingouins, sur trois îles de l'archipel Palmer en Antarctique. 

```{r, layout="l-body"}
knitr::include_graphics("img/lter_penguins.png")
```
Dessin de [Allison Horst](https://allisonhorst.github.io/palmerpenguins/reference/figures/lter_penguins.png)

<br>

## Nuage de points (scatter plot){#scatterplot}

<br>

Intéressons-nous au bec des pingouins en répondant à la question suivante : **quelle est la distribution du rapport entre la hauteur du bec et sa longueur ?**.  
  
Afin de bien comprendre comment construire un graphique avec `ggplot2`, procédons étape par étape.

<br>

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Initialiser l'outil graphique
ggplot(data = pingouins)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Paramètres esthétiques : répartition des variables sur les axes
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm))
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Type de visualisation : points
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point()
```

<br>

Voilà la distribution que nous cherchons à observer. C'est un bon début, mais cela manque de couleurs ...  

<br>

Il existe deux façons d'ajouter des couleurs à un `ggplot` :  

- **définir une couleur pour l'ensemble des points** : on placera alors le paramètre couleur **en dehors de la parenthèse `aes()`**.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Une couleur pour l'ensemble des points
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(colour = "red")
```

- **colorer les points en fonction d'une autre variable** : on placera dans ce cas le paramètre couleur **à l'intérieur de la parenthèse `aes()`**.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Colorer les points en fonction de l'espece
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(aes(colour = espece))
```

Vous pouvez voir qu'une **légende** permettant de différencier les trois espèces a été ajoutée à droite du graphique.

<br>

Nous aimerions utiliser les mêmes **couleurs* que celles de la documentation du jeu de données. Nous utilisons pour cela le paramètre `scale_colour_manual()` : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Modifier les couleurs
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(aes(colour = espece)) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4"))
```

La **taille** des points nous semble trop petite : nous allons l'augmenter à l'aide de `size` :

<aside>
Prend une valeur numérique, par défaut 1
</aside>

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Augmenter la taille des points
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(aes(colour = espece),
             size = 3) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4"))
```

Afin de rendre le graphique plus lisible, nous pouvons ajouter de la **transparence** aux points à l'aide du paramètre `alpha` : 

<aside>
Entre 0 et 1, par opacité croissante
</aside>

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Ajouter de la transparence
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4"))
```

Nous allons maintenant ajouter un **titre** et un **sous-titre** à notre graphique, et modifier les **titres des axes** pour les rendre plus explicites : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Ajouter ou modifier les titres du graphique et des axes
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Rapport entre la hauteur et la longueur du bec",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur du bec (mm)",
       y = "Hauteur du bec (mm)")
```

Le fond gris du graphique est proposé par défaut par `ggplot2` : il s'agit d'un **thème** définissant l'apparence générale du graphique (couleurs de l'arrière-plan, de la grille, présence ou non d'un cadre, ...).


Nous allons utiliser l'un des autres thèmes prédéfinis dans `ggplot2`, le thème **"minimal"** à l'aide du paramètre `theme_minimal()`.

Il en existe d'autres : `theme_light()`, `theme_bw()`, `theme_void()`, ... 
N'hésitez pas à les essayer pour trouver celui qui vous convient le mieux ! 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Changer le thème
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Rapport entre la hauteur et la longueur du bec",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur du bec (mm)",
       y = "Hauteur du bec (mm)") +
  theme_minimal()
```

### Une note sur les formes et les couleurs

Nous pourrions également modifier la forme de nos points, à l'aide du paramètre `shape`. 
Il existe 25 types de points, comme montré ci-dessous.

```{r, layout="l-body"}
knitr::include_graphics("img/geom_point_shapes.png")
```

<br>

La façon de colorer les points dépend de la forme choisie : 

- couleur appliquée au **contour** pour les formes **0 à 14** à l'aide de `colour = ...`  

- couleur appliquée à l'**intérieur** pour les formes **15 à 20** à l'aide de `fill = ...`  

- couleur appliquée **au contour et à l'intérieur** pour les formes **21 à 24** à l'aide de ces deux paramètres, avec la même couleur ou des couleurs différentes. Pour ces cinq formes, la largeur du contour peut être modifiée à l'aide de `stroke = ...` (prend une valeur numérique).

<br>

Pour donner un exemple, nous pouvons ajouter à nos points un contour noir : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Changer la forme des points
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(aes(fill = espece),
             shape = 23,
             stroke = 2,
             colour = "black",
             size = 3,
             alpha = 0.5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Rapport entre la hauteur et la longueur du bec",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur du bec (mm)",
       y = "Hauteur du bec (mm)") +
  theme_minimal()
```

**Attention à la logique du code !!** Nous avons choisi de colorer l'intérieur de nos points en fonction de l'espèce : `geom_point(aes(fill = espece))`. Il faut donc modifier la ligne qui nous permet de changer les couleurs : **`scale_fill_manual()`** remplace `scale_colour_manual()` utilisé précédemment. 

<br>

Le package `ggplot2` propose de nombreuses palettes de couleurs : 

<aside>
[Palettes prédéfinies dans `ggplot2`](http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#rcolorbrewer-palette-chart)
</aside>

```{r, layout="l-body"}
knitr::include_graphics("img/rcolorbrewer.png")
```

Ces différentes palettes peuvent être utilisées à l'aide de `scale_colour_brewer()` ou `scale_fill_brewer()`.
Essayons la palette *Set3* : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Utiliser une palette de couleurs
ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5) +
  scale_colour_brewer(palette = "Set3") +
  labs(title = "Rapport entre la hauteur et la longueur du bec",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur du bec (mm)",
       y = "Hauteur du bec (mm)") +
  theme_minimal()
```

Il existe beaucoup d'autres palettes, accessibles via des packages, dont la liste est [accessible ici](https://github.com/EmilHvitfeldt/r-color-palettes).

<br>

## Histogramme {#histogram}

<br>

Essayons maintenant de répondre à la question suivante : **quelle est la distribution de la longueur des ailes ?**.
<br>

Nous allons pour cela générer un histogramme à l'aide de `geom_histogram()` :

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Histogramme
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm)) +
  geom_histogram(aes(fill = espece),
                 alpha = 0.5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la longueur des ailes",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur des ailes (mm)",
       y = "Fréquence") +
  theme_minimal()
```

Il existe trois manières d'**arranger la position des histogrammes** des différents groupes : 

**1) `position = "stack` (par défaut)** : voir ci-dessus.

**2) `position = "identity"`** : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Histogramme - position = "identity"
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm)) +
  geom_histogram(aes(fill = espece),
                 alpha = 0.5,
                 position = "identity") +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la longueur des ailes",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur des ailes (mm)",
       y = "Fréquence") +
  theme_minimal()
```

**3) `position = "dodge"`**

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Histogramme - position = "dodge"
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm)) +
  geom_histogram(aes(fill = espece),
                 alpha = 0.5,
                 position = "dodge") +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la longueur des ailes",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur des ailes (mm)",
       y = "Fréquence") +
  theme_minimal()
```

<br>

Lorsque vous exécutez ce code, vous pouvez lire le message suivant dans la console : **`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.**

Cela vous signale que le nombre de classes (bins) choisi pour l'histogramme n'est peut-être pas idéal.

Vous pouvez modifier ces classes de deux façons : 

**1) en modifiant la largeur de chaque classe sur l'axe x : `binwidth = ...`**

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Histogramme - position = "identity" - binwidth = 0.5
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm)) +
  geom_histogram(aes(fill = espece),
                 alpha = 0.5,
                 position = "identity",
                 binwidth = 0.5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la longueur des ailes",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur des ailes (mm)",
       y = "Fréquence") +
  theme_minimal()
```

**2) en modifiant le nombre de classes à afficher : `bins = ...`**

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Histogramme - position = "identity" - bins = 15
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm)) +
  geom_histogram(aes(fill = espece),
                 alpha = 0.5,
                 position = "identity",
                 bins = 15) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la longueur des ailes",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur des ailes (mm)",
       y = "Fréquence") +
  theme_minimal()
```

<br>

## Boîtes à moustaches (box plot) {#boxplot}

Intéressons-nous maintenant à la masse de nos pingouins : **les masses des trois espèces sont-elles similaires ?**  

Nous allons créer un graphique en boîte à moustaches à l'aide de `geom_boxplot()` : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Boxplots
ggplot(data = pingouins,
       mapping = aes(x = espece,
                     y = masse_g)) +
  geom_boxplot(aes(colour = espece)) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la masse corporelle",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Espèce",
       y = "Masse (g)") +
  theme_minimal()
```

<br>

Nous pouvons apporter quelques modifications à ce graphique : 

- comme il y a une boîte à moustaches par espèce, nous **pouvons supprimer la légende à l'aide de `show_legend = FALSE`**  

- pour la même raison, nous pouvons **supprimer le titre de l'axe x : `labs(x = "")`**  

- nous pouvons **supprimer les données aberrantes (outliers) : `outlier.shape = NA`**  

- **réduire la largeur des boxplots avec `width`**

- **ajouter de la couleur à l'intérieur des boîtes à moustaches avec `aes(fill = espece)`** : bien penser à ajouter `scale_fill_manual()` !

- **augmenter l'épaisseur des lignes avec `lwd`** (line width)

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Boxplots avec quelques modifications
ggplot(data = pingouins,
       mapping = aes(x = espece,
                     y = masse_g)) +
  geom_boxplot(aes(colour = espece,
                   fill = espece),
               show.legend = FALSE,
               outlier.shape = NA,
               width = 0.25,
               alpha = 0.5,
               lwd = 0.75) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la masse corporelle",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "",
       y = "Masse (g)") +
  theme_minimal()
```

<br>

Si nous préférons des boxplots horizontaux, nous pouvons procéder de deux façons : 

**1) inverser les variables x et y**, en pensant bien à modifier également les titres des axes avec `labs()` : 

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Boxplots horizontaux : inverser les variables x et y
ggplot(data = pingouins,
       mapping = aes(x = masse_g,
                     y = espece)) +
  geom_boxplot(aes(colour = espece,
                   fill = espece),
               show.legend = FALSE,
               outlier.shape = NA,
               width = 0.25,
               alpha = 0.5,
               lwd = 0.75) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la masse corporelle",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Masse (g)",
       y = "") +
  theme_minimal()
```

<br>

**2) utiliser `coord_flip()`** pour inverser les coordonnées : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Boxplots horizontaux : inverser les coordonnées avec coord_flip()
ggplot(data = pingouins,
       mapping = aes(x = espece,
                     y = masse_g)) +
  geom_boxplot(aes(colour = espece,
                   fill = espece),
               show.legend = FALSE,
               outlier.shape = NA,
               width = 0.25,
               alpha = 0.5,
               lwd = 0.75) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la masse corporelle",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "",
       y = "Masse (g)") +
  coord_flip() +
  theme_minimal()
```

<br>

Nous pouvons **ajouter à ces box plots des scatter plots** pour visualiser les données sous-jacentes :

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Boxplots + scatter plots
ggplot(data = pingouins,
       mapping = aes(x = espece,
                     y = masse_g)) +
  geom_boxplot(aes(colour = espece,
                   fill = espece),
               show.legend = FALSE,
               outlier.shape = NA,
               width = 0.25,
               alpha = 0.5,
               lwd = 0.75) +
  geom_point(aes(colour = espece),
             show.legend = FALSE,
             alpha = 0.25) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la masse corporelle",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "",
       y = "Masse (g)") +
  coord_flip() +
  theme_minimal()
```

<br>

Nous aimerions **espacer les points** pour rendre le graphique plus lisible. Nous allons pour cela utiliser un autre type de visualisation de nuages de points : `geom_jitter()`. 

Les paramètres `height` et `width` permettent d'ajuster l'étalement du nuage respectivement en hauteur et en largeur. 

L'utilisation de l'un ou l'autre de ces paramètres dépendra de l'orientation de nos nuages de points (répartition des variables sur les axes x et y et utilisation de `coord_flip()`).

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Boxplots + geom_jitter()
ggplot(data = pingouins,
       mapping = aes(x = espece,
                     y = masse_g)) +
  geom_boxplot(aes(colour = espece,
                   fill = espece),
               show.legend = FALSE,
               outlier.shape = NA,
               width = 0.25,
               alpha = 0.5,
               lwd = 0.75) +
  geom_jitter(aes(colour = espece),
             show.legend = FALSE,
             alpha = 0.25,
             width = 0.25) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la masse corporelle",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "",
       y = "Masse (g)") +
  coord_flip() +
  theme_minimal()
```

<br>

## Diagramme en bâtons (bar plot) {#barplot}

<br>

**Quelle espèce compte le plus de pingouins ?**  

Nous allons utiliser `geom_bar()` pour visualiser le nombre de pingouins par espèce : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Barplot
ggplot(data = pingouins,
       mapping = aes(x = espece,
                     fill = espece)) +
  geom_bar(show.legend = FALSE) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  theme_minimal()
```

<br>

Les espèces étant déjà notées sur l'axe x, nous utilisons `show.legend = FALSE` pour alléger le graphique.

<br>

Nous souhaiterions ajouter des **étiquettes de texte** au-dessus des barres pour indiquer le nombre de pingouins par espèce. Nous allons pour cela ajouter une couche à l'aide de `geom_text()` : 

- `aes(label = ..count..)` : indique que les étiquettes contiendront le nombre d'observations par groupe défini précédemment (les espèces).

- `stat = "count"` : nécessaire pour que le code fonctionne.  

- `vjust = -1` : alignement vertical des étiquettes, vous pouvez essayer différentes valeurs pour voir le résultat.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Barplot + geom_text()
ggplot(data = pingouins,
       mapping = aes(x = espece,
                     fill = espece)) +
  geom_bar(show.legend = FALSE) +
  geom_text(aes(label = ..count..),
            stat = "count",
            vjust = -1) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  theme_minimal()
```

Vous pouvez voir que l'étiquette pour l'espèce Adélie est coupée ... il y a plusieurs façons de régler ce problème. Nous allons simplement **positionner les étiquettes à l'intérieur des barres**, **augmenter la taille des caractères** et **colorer le texte en blanc** pour le rendre plus lisible.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Barplot + geom_text() + texte dans les barres
ggplot(data = pingouins,
       mapping = aes(x = espece,
                     fill = espece)) +
  geom_bar(show.legend = FALSE) +
  geom_text(aes(label = ..count..),
            stat = "count",
            vjust = 1.5,
            colour = "white",
            size = 5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  theme_minimal()
```

Comme vous pouvez le voir, les espèces sont placées le long de l'axe x par **ordre alphabétique**.

Nous préférerions qu'elles soient triées par ordre décroissant de nombre de pingouins. Nous allons voir trois façons de procéder : 

<br>

**1) créer un objet intermédiaire** : approche à éviter car elle ajoute un objet dans l'environnement et n'est **pas dynamique**, c'est-à-dire que le code ne sera pas utilisable pour d'autres cas de figure.

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Tri avec création d'un objet intermédiaire

pingouins_tri <- pingouins %>% 
  mutate(espece = factor(espece,
                         levels = c("Adelie", "Gentoo", "Chinstrap")))

ggplot(data = pingouins_tri,
       mapping = aes(x = espece,
                     fill = espece)) +
  geom_bar(show.legend = FALSE) +
  geom_text(aes(label = ..count..),
            stat = "count",
            vjust = 1.5,
            colour = "white",
            size = 5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  theme_minimal()
```

<br>

**2) modifier l'objet *pingouins* dans la fonction ggplot** : cette approche utilise la fonction `mutate()` du package `dplyr` pour créer le facteur espece. Le code ne crée pas de nouvel objet dans l'environnement. Il nous faut par contre **définir les niveaux du facteur** avec `levels()`.

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Tri dans la fonction ggplot() à l'aide de mutate()

ggplot(data = mutate(pingouins,
                     espece = factor(espece,
                                     levels = c("Adelie", "Gentoo", "Chinstrap"))),
       mapping = aes(x = espece,
                     fill = espece)) +
  geom_bar(show.legend = FALSE) +
  geom_text(aes(label = ..count..),
            stat = "count",
            vjust = 1.5,
            colour = "white",
            size = 5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  theme_minimal()
```

<br>

**3) utiliser les fonctionnalités du [package `forcats`**](https://forcats.tidyverse.org/) : ce package, qui fait partie du Tidyverse, permet d'effectuer des opérations sur des facteurs. C'est l'**approche la plus dynamique** : R transforme une variable en facteur et détermine automatiquement les niveaux. Nous n'avons donc plus besoin de préciser les niveaux. Nous pouvons par exemple trier les niveaux d'un facteur par ordre d'apparition avec `fct_inseq()`, ou par ordre de nombre d'observations à l'aide de `fct_infreq()`.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Tri dans la fonction ggplot() à l'aide des fonctionnalites du package forcats

ggplot(data = mutate(pingouins,
                     espece = fct_infreq(espece)),
       mapping = aes(x = espece,
                     fill = espece)) +
  geom_bar(show.legend = FALSE) +
  geom_text(aes(label = ..count..),
            stat = "count",
            vjust = 1.5,
            colour = "white",
            size = 5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  theme_minimal()
```

<br>

Comme nous l'avions fait pour les boxplots, nous pouvons **changer l'orientation** des barres.

Nous allons modifier quelques éléments du code : 

- en basculant les espèces le long de l'axe y, l'espèce ayant le plus grand nombre de pingouins va se retrouver en bas du graphique. En effet, la variable espece étant un facteur avec des niveaux ordonnés, le premier niveau du facteur se retrouve au plus près de l'origine de l'axe : à gauche si les barres sont orientées verticalement, en bas si elles sont orientées horizontalement. Pour inverser l'ordre des niveaux, nous utilisons `fct_rev()`.

- nous modifions l'alignement des étiquettes en remplaçant `vjust` par `hjust`  

- nous réduisons la largeur des barres à l'aide du paramètre `width`

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Barplot horizontal

ggplot(data = mutate(pingouins,
                     espece = fct_rev(fct_infreq(espece))),
       mapping = aes(x = espece,
                     fill = espece)) +
  geom_bar(width = 0.75,
           show.legend = FALSE) +
  geom_text(aes(label = ..count..),
            stat = "count",
            hjust = 1.5,
            colour = "white",
            size = 5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  coord_flip() +
  theme_minimal()
```

<br>

### Une note sur l'utilisation du pipe `%>%`  

<br>

Nous pouvons également utiliser le **pipe `%>%`** que nous avions vu dans le [tutoriel sur le Tidyverse](https://codons.netlify.app/posts/manipuler-donnees-tidyverse/#rename) pour enchaîner les opérations de tri puis la création du graphique.

Cette façon de procéder permet, quand nous manipulons un jeu de données (ajout d'une colonne par exemple), de s'assurer que nous n'avons **pas fait d'erreur** avant de générer le graphique, le tout **sans avoir besoin de créer d'objet intermédiaire**.

L'utilisation du pipe permet également de bénéficier de l'**auto-complétion** à l'aide de la touche `Tab`, ce qui est plutôt appréciable quand nos variables portent des noms complexes ou que le code contient de nombreux paramètres.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Utilisation du pipe %>%

pingouins %>% 
  mutate(espece = fct_rev(fct_infreq(espece))) %>% 
  ggplot(mapping = aes(x = espece,
                       fill = espece)) +
  geom_bar(width = 0.75,
           show.legend = FALSE) +
  geom_text(aes(label = ..count..),
            stat = "count",
            hjust = 1.5,
            colour = "white",
            size = 5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  coord_flip() +
  theme_minimal()
```

<br>

# Graphiques multiples {#facet}

<br>

Quel est le **rapport entre la longueur du bec et la longueur des ailes** ? 

Nous pouvons créer un nuage de points avec les trois espèces sur un même graphique, comme nous l'avons fait jusqu'ici : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Scatter plot : 1 graphique pour les 3 especes
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm,
                     y = bec_lngr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Rapport entre la longueur du bec et la longueur des ailes",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "Longueur de l'aile (mm)",
       y = "Longueur du bec (mm)") +
  theme_minimal()
```

<br>

Nous souhaitons maintenant visualiser ces données en **sépérant les graphiques par espèce et par île**.

Nous pourrions pour cela créer séparément les graphiques à l'aide de la fonction `filter()`. `ggplot2` possède deux fonctions qui le font directement : **`facet_wrap()`** et **`facet_grid()`**.

<br>

## `facet_wrap()`  

<br>

Nous allons simplement ajouter une couche à notre graphique précédent en précisant quelle variable sert à séparer les données (à l'aide d'un **tilde ~**).

Les fonctions `facet_...()` génèrent automatiquement des étiquettes de texte, nous ajoutons donc le paramètre `show.legend = FALSE`.

Nous modifions également le **thème** pour rendre les noms des espèces plus lisibles :

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# facet_wrap() : 1 graphique par espece
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm,
                     y = bec_lngr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5,
             show.legend = FALSE) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Rapport entre la longueur du bec et la longueur des ailes",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "Longueur de l'aile (mm)",
       y = "Longueur du bec (mm)") +
  facet_wrap(~espece) +
  theme_light()
```

Nous pouvons modifier l'**orientation** des graphiques à l'aide du paramètre `dir = ...` (par défaut `h`, `v` pour des graphiques orientés verticalement).  

Nous pouvons également **déplacer l'étiquette de titre** (noms des espèces dans notre cas) avec le paramètre `strip.position = ...` (par défaut `top`, peut prendre les valeurs `right`, `bottom` ou `left`) : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# facet_wrap() : 1 graphique par espece + paramètres
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm,
                     y = bec_lngr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5,
             show.legend = FALSE) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Rapport entre la longueur du bec et la longueur des ailes",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "Longueur de l'aile (mm)",
       y = "Longueur du bec (mm)") +
  facet_wrap(~espece,
             dir = "v",
             strip.position = "right") +
  theme_light()
```

<br>

## `facet_grid()`  

<br>

Quand nous souhaitons utiliser deux variables discrètes (non continues, avec des catégories) pour séparer nos données, nous utilisons la fonction `facet_grid()`. 

La syntaxe est similaire et nous précisons avec l'opérateur `lignes ~ colonnes` comment répartir les variables : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# facet_grid() : 1 graphique par combinaison de variables
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm,
                     y = bec_lngr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5,
             show.legend = FALSE) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Rapport entre la longueur du bec et la longueur des ailes",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "Longueur de l'aile (mm)",
       y = "Longueur du bec (mm)") +
  facet_grid(espece ~ ile) +
  theme_light()
```

**Toutes les combinaisons** possibles sont affichées, ce qui génère des graphiques vides dans le cas où la combinaison en question ne possède aucune observation.

Nous pouvons déplacer les étiquettes de titres à l'aide du paramètre `switch` qui peut prendre trois valeurs : `x` pour déplacer les étiquettes de l'axe x en bas des graphiques, `y` pour déplacer les étiquettes des axes y à gauche des graphiques, ou `both` pour effectuer les deux modifications simultanément : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# facet_grid() : 1 graphique par combinaison de variables + paramètre switch
ggplot(data = pingouins,
       mapping = aes(x = aile_lngr_mm,
                     y = bec_lngr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5,
             show.legend = FALSE) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Rapport entre la longueur du bec et la longueur des ailes",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "Longueur de l'aile (mm)",
       y = "Longueur du bec (mm)") +
  facet_grid(espece ~ ile,
             switch = "x") +
  theme_light()
```

<br>

# Exporter un graphique {#exporter}

<br>

Jusqu'à présent, nos graphiques apparaissaient dans l'onglet **Plots** mais n'étaient pas sauvegardés. 

Nous allons voir deux façons d'exporter un graphique : 

- directement depuis l'onglet Plot  

- en ligne de commande avec `ggsave()`

<br>

## Depuis l'onglet *Plots*

<br>

L'onglet **Plots** vous permet de naviguer entre vos graphiques, d'ouvrir le graphique actuellement affiché dans une nouvelle fenêtre, d'exporter votre graphique, de le supprimer ou de supprimer tous les graphiques de la session de travail.

<br>

En cliquant sur **Export**, vous avez trois options : 

- sauvegarder le graphique **sous forme d'image**

- sauvegarder le graphique **au format PDF**  

- **copier le graphique** dans le presse-papiers (par exemple pour le coller dans un document)

```{r, layout="l-body"}
knitr::include_graphics("img/export_ggplot_01.png")
```

<br>

Nous allons exporter le barplot horizontal sous forme d'image : cliquez sur **Export** puis **Save as image**. 

```{r, layout="l-body"}
knitr::include_graphics("img/export_ggplot_02.png")
```

Vous aurez alors le choix entre plusieurs **extensions** (`.png`, `.jpeg`, ...).

Vous pourrez également **redimensionner** votre graphique (en conservant ou non le ratio des dimensions), choisir le **dossier de destination** et **renommer** votre fichier (le nom proposé par défaut n'est pas très explicite ...).

<br>

## Avec `ggsave()`

<br>

Cette fonction permet d'exporter un graphique au format **.png** dans un répertoire, avec les dimensions et la résolution de notre choix.

Vous devez tout d'abord **assigner le graphique à exporter dans un objet**. R étant un langage de programmation orienté objet, tout ce que vous manipulez (les fichiers importés, les fonctions et même les graphiques) sont stockés dans la mémoire vive sous forme d'objet (visibles dans l'onglet **Environment**).

Reprenons le code utilisé pour générer le barplot horizontal et assignons-le à l'objet `barplot_especes` : 

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Assigner le graphique à un objet
barplot_especes <- ggplot(data = mutate(pingouins,
                                        espece = fct_rev(fct_infreq(espece))),
                          mapping = aes(x = espece,
                                        fill = espece)) +
  geom_bar(width = 0.75,
           show.legend = FALSE) +
  geom_text(aes(label = ..count..),
            stat = "count",
            hjust = 1.5,
            colour = "white",
            size = 5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  coord_flip() +
  theme_minimal()
```

Tout ce qui vous a permis de créer ce graphique est désormais stocké dans l'objet **barplot_especes**. En procédant ainsi, vous n'aurez plus d'aperçu de votre graphique dans l'onglet **Plots**.

Pour ce faire, vous avez deux options : 

- appeler l'objet `barplot_especes` dans la console ou le script et exécuter la commande  

- **entourer le code précédant par des parenthèses** : cela permet d'assigner le graphique dans l'objet et de l'afficher dans l'onglet Plots.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Assigner le graphique à un objet et l'afficher
(barplot_especes <- ggplot(data = mutate(pingouins,
                                         espece = fct_rev(fct_infreq(espece))),
                           mapping = aes(x = espece,
                                         fill = espece)) +
  geom_bar(width = 0.75,
           show.legend = FALSE) +
  geom_text(aes(label = ..count..),
            stat = "count",
            hjust = 1.5,
            colour = "white",
            size = 5) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins",
       subtitle = "pour trois espèces de l'archipel Palmer",
       x = "",
       y = "") +
  coord_flip() +
  theme_minimal()
)
```

<br>

Nous pouvons maintenant sauvegarder le graphique à l'aide de la fonction `ggsave()` en utilisant les paramètres suivants :  

- `figs/barplot_especes.png` : emplacement du fichier à exporter (dossier/nom-du-fichier)  

- `barplot_especes` : nom de l'objet à exporter  

- `dpi = 320` : résolution de l'image  

- `width = 12` : largeur de l'image  

- `height = 6` : hauteur de l'image


```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
ggsave("figs/barplot_especes.png", barplot_especes, dpi = 320, width = 12, height = 6)
```

Il existe d'autres paramètres, n'hésitez pas explorer l'aide de la fonction à l'**aide de la commande `?ggsave`**. 

Vous pouvez essayer différentes options et valeurs pour voir le résultat.

Ouvrez le fichier `barplot_especes.png` et comparez ce fichier avec le visuel affiché dans votre session RStudio.

```{r, layout="l-body"}
knitr::include_graphics("img/barplot_especes.png")
```

**Il n'est pas rare d'avoir quelques surprises** ! La taille des lettres peut par exemple être plus petite dans le fichier exporté que dans l'aperçu RStudio. 

Il est toujours utile d'**exporter son graphique** et de **vérifier le rendu** pour **rectifier les paramètres si nécessaire**.

[Cet article](https://www.christophenicault.com/post/understand_size_dimension_ggplot2/) explique en détail comment paramétrer la taille et la résolution d'une image.

<br>

# Améliorer ses graphiques {#ameliorer}

<br>

Nous avons vu comment créer les principaux types de graphiques ainsi que certains paramètres permettant de modifier leur apparence. Il existe énormément de paramètres permettant de modifier nos graphiques pour les rendre plus attractifs. **Les possibilités sont pour ainsi dire infinies !** 

<br>

La suite de ce tutoriel vous donnera quelques éléments pour améliorer vos graphiques, n'hésitez pas à aller voir la section **Liens** du blog pour trouver d'autres ressources qui vous aideront à creuser encore davantage les possibilités de `ggplot2`.

<br>

## Les différents éléments de `theme()`

<br>

Un graphique se compose de **quatre parties** principales, dont nous pouvons paramétrer les différents éléments : 

- le **"panel"** qui contient les éléments géométriques de visualisation  

- le **"plot"** qui contient ce qui entoure le panel (titre, sous-titre, ...)  

- les **axes** avec les titres, les graduations, ...  

- la **légende**

<br>

Nous allons voir comment modifier chaque partie d'un graphique, en utilisant le scatter plot généré au début de ce tutoriel. 

Commençons par reprendre le code utilisé et assignons-le à un objet. Nous pourrons ensuite ajouter les couches apportant les modifications : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Scatter plot basique
(p <- ggplot(data = pingouins,
       mapping = aes(x = bec_lngr_mm,
                     y = bec_htr_mm)) +
  geom_point(aes(colour = espece),
             size = 3,
             alpha = 0.5) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  labs(title = "Rapport entre la hauteur et la longueur du bec",
       subtitle = "pour trois espèces de pingouins de l'archipel Palmer",
       x = "Longueur du bec (mm)",
       y = "Hauteur du bec (mm)")
 )
```

<br>

### Le **panel**

<br>

```{r, layout="l-body-outset"}
knitr::include_graphics("img/ggplot_themes_panel.png")
```

Nous allons pouvoir définir des paramètres pour ces différents éléments, selon la syntaxe suivante : **`nom-du-parametre = element_...()`**.

En fonction de ce que nous paramétrons, nous allons utiliser par exemple `element_rect()` (contour et intérieur d'une zone rectangulaire), `element_line()` (couleur et épaisseur d'une ligne) ou `element_text()` (police de caractères, taille et couleur du texte, alignement).

<br>

Nous allons modifier les éléments suivants du panel : 

- **couleur de l'arrière-plan** avec `panel.background = element_rect(fill = ..., colour = ...)`  
- **couleur et de la bordure** avec `panel.border = element_rect(...)` (attention, la bordure se paramètre comme une zone rectangulaire : il faut donc préciser `fill = NA` pour que l'arrière-plan du panel conserve la couleur définie dans `panel.background()`)  

- **retirer les lignes de graduations mineures** avec `panel.grid.minor = element_blank()`  

- **couleur et type des lignes de graduations majeures** avec `panal.grid.major = element_line(colour = ..., linetype = ...)`

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Parametrer les elements du panel
(p1 <- p +
  theme(panel.background = element_rect(fill = "#1d3557", colour = NA),
        panel.border = element_rect(fill = NA, colour = "white", size = 1),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_line(colour = "white",
                                        linetype = "dotted"))
)
```

<br>

### Le plot

<br>

```{r, layout="l-body-outset"}
knitr::include_graphics("img/ggplot_themes_plot.png")
```

Nous allons utiliser la **même couleur pour l'arrière-plan de la zone de plot (`plot.background()`)**, ce qui nécessitera de modifier la **couleur du titre (`plot.title`) et du sous-titre (`plot.subtitle`)** (et plus tard des titres et du texte des axes et de la légende).

Nous allons également utiliser `plot.margin()` pour **augmenter l'espace** entre le bord supérieur de la zone de plot et le titre. Les fonctions permettant de modifier les marges s'utilisent de la manière suivante : `plot.margin = margin(top = ..., right = ..., bottom = ..., left = ...)`. Vous pouvez utiliser les initiales : `margin(t = ..., r = ..., b = ..., l = ...)` ou simplement les valeurs numériques des quatres paramètres séparées par des virgules.

Nous pouvons aligner le titre et le sous-titre au centre (`hjust = 0.5`) et ajouter de l'espace entre le haut du panel et le sous-titre pour aérer notre graphique. Nous pouvons pour cela ajouter un paramètre `margin` dans l'élément `plot.subtitle = element_text()`.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Parametrer les elements du plot
(p2 <- p1 +
  theme(plot.background = element_rect(fill = "#1d3557", colour = NA),
        plot.margin = margin(t = 10, r = 10, b = 10, l = 10),
        plot.title = element_text(colour = "white", size = 20,
                                  hjust = 0.5),
        plot.subtitle = element_text(colour = "white", size = 15,
                                     hjust = 0.5, margin = margin(b = 5)))
)
```

Le titre et le sous-titre de notre graphique sont alignés sur le centre de la zone panel. Pour les aligner par rapport à la zone plot, nous utilisons un paramètre supplémentaire : `plot.title.position = "plot"`.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Aligner le titre et le sous-titre sur le centre de la zone plot
(p2 <- p1 +
  theme(plot.background = element_rect(fill = "#1d3557", colour = NA),
        plot.margin = margin(t = 10, r = 10, b = 10, l = 10),
        plot.title = element_text(colour = "white", size = 20,
                                  hjust = 0.5),
        plot.title.position = "plot",
        plot.subtitle = element_text(colour = "white", size = 15,
                                     hjust = 0.5, margin = margin(b = 15)))
)
```

<br>

### Les axes

<br>

```{r, layout="l-body-outset"}
knitr::include_graphics("img/ggplot_themes_axis.png")
```

Nous allons modifier la **couleur des titres des axes**. Nous pourrions le faire pour les axes x et y à l'aide de `axis.title = element_text(colour = "white)`. 

Nous aimerions cependant **augmenter l'espace entre le titres des axes et les axes**, nous devons pouvons utiliser `axis.title.x = element_text(colour = "white", margin = margin(t = 10))` et `axis.title.y = element_text(colour = "white", margin = margin(r = 10))` pour respecter l'orientation des titres.

Nous allons également modifier la couleur du texte des axes avec `axis.text = element_text(...)`.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Parametrer les axes
(p3 <-p2 +
  theme(axis.title.x = element_text(colour = "white",
                                    margin = margin(t = 10)),
        axis.title.y = element_text(colour = "white",
                                    margin = margin(r = 10)),
        axis.text = element_text(colour = "white"))
)
```

Nous pourrions également **retirer les marques des graduations** à l'aide de `axis.ticks = element_blank()`, mais celles-ci ne sont pas visibles avec les modifications apportées au graphique.

Pour montrer l'intérêt de ce paramètre, reprenons notre premier graphique : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Premier scatter plot
p
```

Nous pouvons retirer de ces marques : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Supprimer les marques des graduations
p +
  theme(axis.ticks = element_blank())
```

<br>

### La légende

<br>

```{r, layout="l-body-outset"}
knitr::include_graphics("img/ggplot_themes_legend.png")
```

Nous allons modifier la **couleur de l'arrière-plan de la légende** (pour deux zones : le texte et les points), **modifier la couleur et la taille du texte** et **supprimer le titre**.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Parametrer la legende
(p4 <- p3 +
  theme(legend.background = element_rect(fill = "#1d3557"),
        legend.key = element_blank(),
        legend.text = element_text(colour = "white", size = 15),
        legend.title = element_blank())
)
```

Nous pouvons modifier la **position de la légende** : 

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Modifier la position de la legende
(p4 <- p3 +
  theme(legend.background = element_rect(fill = "#1d3557"),
        legend.key = element_blank(),
        legend.text = element_text(colour = "white", size = 15),
        legend.title = element_blank(),
        legend.position = "top")
)
```

La taille, la couleur et la transparence des points de la légende reprennent les paramètres utilisés dans `geom_point()`. Nous aimerions modifier ces éléments de la légende pour augmenter la taille des points et supprimer leur transparence pour simplifier la lecture de la légende. 

Nous utilisons pour cela le **paramètre `guides()`** :

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Modifier la representation des points de la legende
(p4 <- p3 +
  theme(legend.background = element_rect(fill = "#1d3557"),
        legend.key = element_blank(),
        legend.text = element_text(colour = "white", size = 15),
        legend.title = element_blank(),
        legend.position = "top") +
  guides(colour = guide_legend(override.aes = list(alpha = 1,
                                                   size = 5)))
)
```

<br>

## Modifier la police du texte avec `showtext`

<br>

Nous aimerions utiliser d'autres polices de caractères pour notre graphique. 

Le [package `showtext()`](https://github.com/yixuan/showtext) permet d'utiliser des polices **Google fonts** dans nos graphiques, n'hésitez pas à fouiller pour trouver celle qui vous convient ! 

Installez et chargez le package showtext : 

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Installer et charger le package showtext
install.packages("showtext")
library(showtext)
```

Nous allons utiliser la police **Righteous** pour le titre et le sous-titre, et la police **Gruppo** pour la légende et les axes :

```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
library(showtext)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
font_add_google("Righteous", "Righteous")
font_add_google("Gruppo", "Gruppo")
showtext_auto()
```

Nous modifions également les **marges du graphique**, la **taille du texte** et l'**alignement du titre et du sous-titre** : 


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Modifier la police de caractères du titre et du sous-titre
(p5 <- p4 +
  theme(plot.title = element_text(family = "Righteous",
                                  size = 25, margin = margin(t = 5, b = 5)),
        plot.subtitle = element_text(family = "Righteous", size = 20),
        plot.title.position = "panel",
        plot.margin = margin(5, 15, 5, 15),
        legend.text = element_text(family = "Gruppo", size = 20),
        axis.title = element_text(family = "Gruppo", size = 20),
        axis.text = element_text(family = "Gruppo", size = 15))
)
```

<br>

# Combiner des graphiques avec `patchwork`

<br>

Le [package `patchwork`](https://patchwork.data-imaginist.com/) permet de **combiner plusieurs graphiques en une seule image**.

Installons et chargeons ce package : 

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
install.packages("patchwork")
library(patchwork)
```

```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
library(patchwork)
```

Notre objectif est de combiner trois graphiques : 

**1) Un barplot du nombre de pingouins par île**  

**2) Un barplot du nombre de pingouins par espèce**

**3) Un histogramme de la distribution de la masse corporelle**

<br>

Nous allons créer ces trois graphiques séparément. Quelques ajustements seront nécessaires : taille du texte, largeur des barres et des boîtes à moustaches, ... 

<br>

Le code ci-dessous tient compte de ces ajustements, n'hésitez pas à essayer différents réglages des paramètres pour obtenir le graphique qui vous convient ! L'onglet **Plots** de RStudio affiche un graphique peu fidèle au résultat final après exportation de l'image au format .png, il est donc nécessaire de faire des essais, exporter l'image ou l'ouvrir pour faire les ajustements.

Nous allons utiliser la même couleur d'arrière-plan, les mêmes polices, etc. pour les différents graphiques.

Nous pouvons donc définir un thème personnalisé qui contient ces paramètres : nous l'utiliserons comme nous l'avions fait avec `theme_minimal()` par exemple. Nous pourrons modifier d'autres paramètres à l'aide de la fonction `theme()` pour les éléments propres à l'un des graphiques.

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Theme personnalise
theme_perso <- function() {
  theme(panel.background = element_rect(fill = "#1d3557", colour = NA),
        plot.background = element_rect(fill = "#1d3557", colour = NA),
        plot.margin = margin(15, 15, 15, 15),
        plot.title = element_text(family = "Righteous", colour = "white", size = 40, 
                                  margin = margin(b = 20), hjust = 0.5),
        plot.subtitle = element_text(family = "Righteous", colour = "white", size = 20,
                                     margin = margin(b = 10), hjust = 0.5),
        legend.background = element_rect(fill = "#1d3557", colour = NA),
        legend.title = element_blank(),
        legend.text = element_text(family = "Gruppo", colour = "white", size = 40))
}
```

Nous venons de créer une **fonction** : nous pouvons l'appliquer à nos graphiques à l'aide de `theme_perso()`.

<br>

Créons maintenant chacun des graphiques : 

<br>

**1) Barplot du nombre de pingouins par ile**

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# p1 : barplot du nombre de pingouins par ile
p1 <- ggplot(data = mutate(pingouins,
                     ile = fct_rev(fct_infreq(ile))),
       mapping = aes(x = ile)) +
  geom_bar(width = 0.75,
           fill = "#dcf3ff") +
  geom_text(aes(label = ..count..),
            stat = "count",
            family = "Gruppo",
            hjust = 1.5,
            colour = "#1d3557",
            size = 20) +
  labs(title = "Nombre de pingouins par île",
       x = "",
       y = "") +
  coord_flip() +
  theme_perso() +
  theme(panel.grid = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_text(family = "Gruppo", colour = "#dcf3ff",
                                   size = 40))
```

<br>

**2) Barplot du nombre de pingouins par espece**

Nous utilisons ici `show.legend = TRUE` pour que la correspondance entre les couleurs et les espèces apparaisse dans notre graphique. Nous pourrons déplacer la légende avec `patchwork` quand nous combinerons les trois graphiques.

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# p2 : barplot du nombre de pingouins par espece
p2 <- ggplot(data = mutate(pingouins,
                     espece = fct_rev(fct_infreq(espece))),
       mapping = aes(x = espece,
                     fill = espece)) +
  geom_bar(width = 0.75) +
  geom_text(aes(label = ..count..),
            stat = "count",
            family = "Gruppo",
            hjust = 1.5,
            colour = "white",
            size = 20) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Nombre de pingouins par espèce",
       x = "",
       y = "") +
  coord_flip() +
  theme_perso() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank())
```

<br>

**3) Boxplot + scatter plot de la distribution de la masse**

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# p3 : boxplot + scatter plot de la distribution de la masse 
p2 <- ggplot(data = pingouins,
       mapping = aes(x = espece,
                     y = masse_g / 1e3)) +
  geom_boxplot(aes(colour = espece,
                   fill = espece),
               show.legend = FALSE,
               outlier.shape = NA,
               width = 0.5,
               alpha = 0.5,
               lwd = 0.75) +
  geom_jitter(aes(colour = espece),
              show.legend = FALSE,
              alpha = 0.25,
              width = 0.25) +
  scale_colour_manual(values = c("Adelie" = "darkorange",
                                 "Chinstrap" = "purple",
                                 "Gentoo" = "cyan4")) +
  scale_fill_manual(values = c("Adelie" = "darkorange",
                               "Chinstrap" = "purple",
                               "Gentoo" = "cyan4")) +
  labs(title = "Distribution de la masse corporelle",
       x = "",
       y = "Masse (kg)") +
  scale_y_continuous(breaks = seq(2, 6, 1),
                     limits = c(2.5, 6.5)) +
  coord_flip() +
  theme_perso() +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.major.x = element_line(colour = "white", 
                                          linetype = "dotted",
                                          size = 0.2),
        plot.title = element_text(margin = margin(b = 25)),
        plot.title.position = "panel",
        axis.title.x = element_text(family = "Gruppo",
                                    colour = "white",
                                    size = 40,
                                    margin = margin(t = 15)),
        axis.text.x = element_text(family = "Gruppo",
                                   colour = "white",
                                   size = 40),
        axis.text.y = element_blank())
```

<br>

**Combiner les trois graphiques avec `patchwork`** : 

La syntaxe de ce package est plutôt simple : nous plaçons les deux barplots côte à côte sur une première ligne, et le boxplot sur un deuxième ligne : **`(p1 + p2) / p3`**.

<br>

Nous précisons ensuite, à l'aide de **`plot_layout()`** que nous voulons une taille relative plus importante pour la deuxième ligne (`heights = c(1, 2)`).

Le code **`guides = "collect"`** indique que les légendes des différents graphiques sont à regrouper (très utile pour éviter d'avoir plusieurs fois la même légende dans le graphique final).

Nous ajoutons un titre global avec **`plot_annotation()`**.

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Combiner les trois graphiques avec patchwork 
p <- (p1 + p2) / p3 +
  patchwork::plot_layout(heights = c(1, 2),
                         guides = "collect") +
  patchwork::plot_annotation(
    title = "Pingouins de l'archipel Palmer",
    theme = theme_perso() +
      theme(plot.title = element_text(size = 100)))

```

<br>

Exportons ce graphique : 

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Exporter le graphique
ggsave("figs/patchwork_pingouins.png", p, dpi = 320, width = 12, height = 6)
```

<br>

Voici le résultat : 

```{r, layout="l-body-outset"}
knitr::include_graphics("img/patchwork_pingouins.png")
```